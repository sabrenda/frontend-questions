<div align="center"><h1><img src="https://img.shields.io/badge/React-20232A?style=for-the-badge&logo=react" alt="js" width="300" height="90"></h1></div>

[⚙️ Back to menu](../README.md)

 <div id="menureact"></div>

| No.|             Вопрос                   |
|:---|:-------------------------------------|
|  | <h4>Введение в React</h4> |
|1| [Что такое React и для чего он нужен?](#react1)|
|2| [React преимущества и недостатки](#react2)|
|3| [Что такое JSX?](#react3)|
|4| [Что такое VirtualDom](#react4)|
|5| [Что такое React fragment?](#react5)|
| | <h4>Основы компонентов</h4> |
|6| [Что такое PROPS?](#react6)|
|7| [Отличие компонента и элемента в Реакте](#react7)|
|8| [Разница между контролируемыми и неконтролируемыми компонентами](#react8)|
|10| [В чем разница между классовыми компонентами и функциональными?](#react10)|
|  | <h4>Функциональные компоненты и хуки</h4> |
|11| [Какие React хуки вы знаете и используете](#react11)|
|12| [Что такое React memo и зачем нужен](#react12)|
|13| [Правила вызова хуков](#react13)|
|14| [Как отследить изменение поля объекта в функциональном компоненте?](#react14)|
|15| [Порядок рендера компонентов, и вызова хуков](#react15)|
|16| [React.memo для чего нужен и когда использовать?](#react16)|
|17| [В каких случаях нужно использовать мемоизацию и зачем](#react17)|
|18| [Что такое контекст в реакт, хук useContext](#react18)|
|19| [Что такое кастомные хуки](#react19)|
|20| [Какие хуки появились React 18, useId, useTransition и тд.](#react20)|
|  | <h4>Хуки</h4> |
|21| [Как работает useState](#react21)|
|25| [Как работает useEffect](#react25)|
|27| [Как работает useLayoutEffect, зачем нужен, отличия от useEffect](#react27)|
|28| [useContext для чего нужен и когда использовать?](#react28)|
|29| [useRef для чего нужен и когда использовать?](#react29)|
|31| [Как работает useMemo](#react31)|
|32| [Как работает useCallback](#react32)|
|34| [Как работает useReducer](#react34)|
|  | <h4>Работа с DOM:</h4> |
|35| [Как отрисовать массив элементов](#react35)|
|36| [Как отрисовать блок по условию?](#react36)|
|37| [Как получить доступ к дом элементу в React](#react37)|
|38| [Что такое порталы `Portal` в React?](#react38)|
|39| [Для чего нужны ключи `key` в списках?](#react39)|
|40| [Как работает проп `children`?](#react40)|
|41| [Зачем нужен хок `forwardRef`](#react41)|
|42| [Хук `useImperativeHandle`](#react42)|
|  | <h4>Жизненный цикл компонентов</h4> |
|43| [Методы жизненного цикла компонента](#react43)|
|44| [Жизненный цикл компонента и методы ЖЦ в классах, порядок вызова](#react44)|
|45| [Как отследить демонтирование функционального компонента?](#react45)|
|  | <h4>Оптимизация</h4> |
|46| [Что такое React `lazy и Suspense`](#react46)|
|47| [Что такое батчинг, его плюсы](#react47)|
|49| [Причины `перерисовки в React`](#react49)|
|50| [Что такое `Виртуализация` и зачем нужна](#react50)|
|51| [Что такое `Throttling`](#react51)|
|52| [Что такое `Debounce`](#react52)|
|  | <h4>Управление состоянием</h4> |
|53| [Что такое `State менеджер`?](#react53)|
|54| [`Flux-архитектура`, Redux и MobX: Что такое Flux - архитектура? Какие сущности она имеет?](#react54)|
|55| [что такое `Redux` и FLUX паттерн](#react55)|
|56| [`Redux vs Context` плюсы и минусы](#react56)|
|57| [Что такое `store в redux`](#react57)|
|58| [Что такое `action в redux`](#react58)|
|59| [Что такое `reducer в redux`](#react59)|
|60| [Что такое `dispatch в redux`](#react60)|
|63| [Асинхронные actions в redux с помощью `thunk`](#react63)|
|64| [`Rtk query/React-query`, Кеширование, инвалидация](#react64)|
|  | <h4>Разработка и архитектура</h4> |
|66| [Что такое Компонент высшего порядка (Higher-Order Component, HOC)?](#react66)|
|67| [Что такое строгий режим и зачем он нужен?](#react67)|
|68| [Расскажите о `React fiber`?](#react68)|
|69| [Расскажите о `React Reconciliation`](#react69)|
|70| [Что такое `Error boundaries`?](#react70)|
|71| [`Next.js, CSR, SSR, ISR, SSG` методы getServerSideProps, getStaticPaths, в чем преимущества SSR, когда стоит юзать](#react71)|
|  | <h4>Разное</h4> |
|72| [Чем `React Native` отличается от `ReactJS`?](#react72)|
|73| [`Отладка` / Как вы отлаживаете приложения React и какие инструменты можете использовать?](#react73)|
|74| [Когда вам стоит использовать Class Component вместо Functional Component?](#react74)|
|75| [Почему ушли от классов к функциям в реакте?](#react75)|
|76| [В каких случаях можно использовать локальное состояние, а в каких лучше использовать глобальный State?](#react76)|
|77| [Декларативность и императивность](#react77)|

---

## Введение в React

<div  id="react1"></div>

## 1. Что такое React и для чего он нужен?

React — это JavaScript-библиотека, разработанная Facebook, которая используется для создания пользовательских интерфейсов, основанных на компонентах. Она позволяет разработчикам создавать большие веб-приложения, которые могут обновляться и отображаться в реальном времени без перезагрузки страницы. React облегчает создание интерактивных пользовательских интерфейсов и предлагает эффективное и гибкое решение для разработки веб- и мобильных приложений.

Вот некоторые особенности и преимущества React:

1.  **Компонентный подход**: React использует компонентную архитектуру, что позволяет создавать большие веб-приложения, которые могут изменять данные, без перезагрузки страницы. Основная идея в том, что приложение состоит из множества изолированных компонентов, которые управляют своим собственным состоянием и рендерингом, и можно легко повторно использовать и комбинировать их.

2.  **Виртуальный DOM (VDOM)**: React использует концепцию виртуального DOM, что позволяет ему быть быстрым. React создает копию DOM в памяти, и когда происходит изменение состояния, React сначала обновляет виртуальный DOM, затем сравнивает его с текущим DOM и наконец обновляет только те части реального DOM, которые были изменены. Это обеспечивает большую производительность и эффективность.

3.  **Однонаправленный поток данных**: React следует принципу "однонаправленного потока данных" или "однонаправленного связывания данных", что делает поток данных в приложении более предсказуемым и понятным.

4.  **Совместимость с другими технологиями**: React можно использовать вместе с другими библиотеками или фреймворками, такими как Angular, jQuery и т. д., что делает его универсальным решением.

5.  **Использование JSX**: JSX — это синтаксис, похожий на HTML, который облегчает написание кода компонентов React. Он преобразуется в JavaScript и предоставляет возможность вставки кода JavaScript прямо в разметку.

6.  **Поддержка сообщества и инструменты**: React имеет большое активное сообщество, обилие документации, обучающих материалов и открытых исходных кодов. Включая такие библиотеки, как Redux и React Router, которые являются стандартом для управления состоянием и маршрутизации в React-приложениях

[Оглавление - React 🔼](#menureact)

<div  id="react2"></div>

## 2. React преимущества и недостатки

React преимущества:
- Virtual DOM - в отличие от реального DOM, занимает мало места и быстро обновляется, тем самым повышая производительность.
- Декларативный подход
- Повторное применение компонентов – уменьшение количества кода, использование JSX.
- Односторонний поток данных – передача пропсов от родителя к ребенку.


Минусы:
- вес библиотеки,
- не полное решение (т.е нужно качать доп. либы для роутинга и тд.),
- отсутствие четкой структуры как в ангуляр например ??

[Оглавление - React 🔼](#menureact)

<div  id="react3"></div>

## 3. Что такое JSX?

  **Подробнее -** [jsx](https://ru.react.js.org/docs/introducing-jsx.html)

По умолчанию чтобы создавать элементы в реакт используется такой синтаксис

```js
const element = React.createElement(
	'h1',
	{className: 'greeting'},
	'Привет, мир!'
);
```
Но мы привыкли видеть его вот таким
```jsx
const element = (
	<h1 className='greeting'>
		Hello, World!
	</h1>;
);
```
именно такая разметка и называется jsx. Это некое расширение языка упрощающее восприятие кода и разработку.

[Оглавление - React 🔼](#menureact)

<div  id="react4"></div>

## 4. Что такое VirtualDom?

**Подробнее -** [Virtual DOM](https://ru.reactjs.org/docs/faq-internals.html)

VirtualDOM это копия DOM дерева и вместо того, чтобы взаимодействовать с DOM напрямую, мы работаем с его легковесной копией. Мы можем вносить изменения в копию, исходя из наших потребностей, а после этого React применяет изменения к реальному DOM.

При этом происходит сравнение DOM-дерева с его виртуальной копией, определяется разница и запускается перерисовка того, что было изменено.

Такой подход работает быстрее, потому как не включает в себя все тяжеловесные части реального DOM.

[Оглавление - React 🔼](#menureact)

<div  id="react5"></div>

## 5. Что такое React fragment?

  **Подробнее -** [fragment](https://ru.reactjs.org/docs/fragments.html)

React.Fragment - это компонент в React, который позволяет возвращать несколько элементов из компонента без необходимости оборачивать их в дополнительный родительский элемент (например, `<div>`).

Пример использования:

```jsx
render() {
  return (
    <React.Fragment>
      <ChildA />
      <ChildB />
      <ChildC />
    </React.Fragment>
  );
}
```

Или короткая форма:

```jsx
render() {
  return (
    <>
      <ChildA />
      <ChildB />
      <ChildC />
    </>
  );
}
```

Это полезно, когда вы не хотите добавлять лишний уровень вложенности в DOM дерево вашего приложения. Он также помогает избегать потенциальных стилевых проблем, которые могут возникнуть при использовании `<div>` или других тегов для группировки дочерних элементов.

[Оглавление - React 🔼](#menureact)

## Основы компонентов

<div  id="react6"></div>

## 6. Что такое PROPS?

**Подробнее -** [props](https://reactjs.org/docs/components-and-props.html)

**Props** (от англ. "properties", "свойства") – данные, которые передаются в компонент из родительского. **Props** доступны только для чтения и не могут быть изменены.

пример:
```jsx
function WelcomeMessage(props) {
  return <h1>Hello, {props.name}!</h1>;
}

function App() {
  return <WelcomeMessage name="Alice" />;
}
```

[Оглавление - React 🔼](#menureact)

<div  id="react7"></div>

## 7. отличие компонента и элемента в Реакте

- **Элемент (React Element)**

Элемент описывает то, что вы хотите увидеть на экране. Элементы являются неизменными. Они образуют дерево и являются основой для отображения пользовательского интерфейса в браузере. Элемент можно создать с помощью функции `React.createElement(type, [props], [...children])` или с помощью JSX.

Пример создания элемента:

```jsx
const element = <h1>Hello, world!</h1>;
```

В этом примере `<h1>Hello, world!</h1>` это JSX-представление элемента React.

- **Компонент (React Component)**

Компоненты, с другой стороны, можно рассматривать как функции, которые принимают входные данные (пропсы) и возвращают React-элементы, которые описывают, что должно появиться на экране. В React есть два типа компонентов: функциональные и классовые.

Пример функционального компонента:

```jsx
function Welcome(props) {
  return <h1>Hello, {props.name}</h1>;
}
```

Пример классового компонента:

```jsx
class Welcome extends React.Component {
  render() {
    return <h1>Hello, {this.props.name}</h1>;
  }
}
```

В обоих примерах `Welcome` это компонент, который принимает один "проп" (`name`) и возвращает React-элемент.

Таким образом, основное различие между элементом и компонентом в React заключается в том, что элемент является тем, что React использует для построения DOM, а компонент это конструкция (функция или класс), которая возвращает React-элемент или дерево React-элементов.

[Оглавление - React 🔼](#menureact)

<div  id="react8"></div>

## 8. Разница между контролируемыми и неконтролируемыми компонентами

У неконтролируемых компонентов данные для каждого элемента ввода хранятся в DOM, а не в компоненте. Вместо того, чтобы писать обработчик событий для всех обновлений состояния, используется ref для получения значений из DOM.

У контролируемых компонентов каждое обновление состояния связана с обработчиком события. Передаем value и onChange.

**Контролируемые компоненты**

Контролируемые компоненты обрабатывают информацию формы через состояние в React. Вместо того чтобы читать значения из DOM, вы читаете и устанавливаете значения через состояние компонента.

Пример контролируемого компонента:
```jsx
import React, { useState } from "react";

function ControlledForm() {
  const [value, setValue] = useState("");

  const handleSubmit = (event) => {
    alert('A name was submitted: ' + value);
    event.preventDefault();
  }

  return (
    <form onSubmit={handleSubmit}>
      <label>
        Name:
        <input type="text" value={value} onChange={e => setValue(e.target.value)} />
      </label>
      <input type="submit" value="Submit" />
    </form>
  );
}
```

**Неконтролируемые компоненты**

Неконтролируемые компоненты обрабатывают информацию формы напрямую через DOM, используя Refs для доступа к элементам формы.

Пример неконтролируемого компонента:
```jsx
import React, { useRef } from "react";

function UncontrolledForm() {
  const input = useRef();

  const handleSubmit = (event) => {
    alert('A name was submitted: ' + input.current.value);
    event.preventDefault();
  }

  return (
    <form onSubmit={handleSubmit}>
      <label>
        Name:
        <input type="text" ref={input} />
      </label>
      <input type="submit" value="Submit" />
    </form>
  );
}
```
В первом примере мы используем хук `useState` для управления значением ввода, а во втором примере мы используем хук `useRef` для создания ссылки на ввод, который затем мы читаем при отправке формы.


[Оглавление - React 🔼](#menureact)

<div  id="react9"></div>

## 9.

[Оглавление - React 🔼](#menureact)

<div  id="react10"></div>

## 10. В чем разница между классовыми компонентами и функциональными?

Классовые и функциональные компоненты в React отличаются прежде всего своей синтаксической структурой и способами обработки состояния и жизненного цикла.

**Классовые компоненты** включают в себя:

1. **Конструктор (constructor)**: Классовые компоненты могут иметь конструктор, который обычно используется для установки начального состояния и привязки методов.
2. **Методы жизненного цикла**: Классовые компоненты предоставляют методы жизненного цикла, такие как `componentDidMount`, `componentDidUpdate`, `componentWillUnmount` и другие.
3. **Render-метод**: Они имеют явный `render()` метод, который возвращает JSX.
4. **Состояние (state)**: У классовых компонентов есть встроенное состояние. Состояние можно изменить с помощью `this.setState()`.

**Функциональные компоненты** включают в себя:

1. **Состояние с помощью хуков**: С приходом React Hooks, функциональные компоненты теперь могут использовать состояние и другие возможности React с помощью `useState`, `useEffect` и других хуков.
2. **Отсутствие методов жизненного цикла**: Функциональные компоненты не имеют методов жизненного цикла. Вместо этого используются хуки, такие как `useEffect`, для выполнения задач, связанных с жизненным циклом.
3. **Возврат JSX**: Функциональные компоненты напрямую возвращают JSX, а не используют явный `render()` метод.

В целом, классовые и функциональные компоненты могут выполнять одни и те же задачи. Выбор между ними часто определяется стилем и предпочтениями команды разработчиков. В последнее время сообщество React все больше переходит к использованию функциональных компонентов и хуков из-за их более простого и сжатого синтаксиса.

[Оглавление - React 🔼](#menureact)

## Функциональные компоненты и хуки

<div  id="react11"></div>

## 11. Что такое хуки в React? Какие React хуки вы знаете и используете

  **Подробнее -** [Краткий обзор хуков](https://ru.reactjs.org/docs/hooks-overview.html)

[Оглавление - React 🔼](#menureact)

  Здесь лучше рассказать то, какие хуки вы используете на своей практике. Хук — это специальная функция, которая позволяет «подцепиться» к возможностям React. Например, хук useState предоставляет функциональным компонентам доступ к состоянию React. Основные React хуки:


Хуки React - это функции, которые позволяют вам "подключаться" к функциональности жизненного цикла React и состояния из функциональных компонентов. Вот некоторые из наиболее распространенных хуков React, которые вы можете использовать:

1. **useState()**: Этот хук позволяет вам добавить состояние в функциональный компонент. Он возвращает массив из двух элементов: текущее значение состояния и функцию для его обновления.

   Пример использования:
   ```javascript
   const [count, setCount] = useState(0);
   ```

2. **useEffect()**: Этот хук позволяет вам выполнять побочные эффекты в функциональном компоненте. Он может использоваться для различных задач, таких как выполнение запросов к API, работы с подписками и т. д.

   Пример использования:
   ```javascript
   useEffect(() => {
      document.title = `Вы нажали ${count} раз`;
   });
   ```

3. **useContext()**: Этот хук позволяет вам использовать контекст без оборачивания компонента в `Context.Consumer`.

   Пример использования:
   ```javascript
   const theme = useContext(ThemeContext);
   ```

4. **useReducer()**: Этот хук представляет собой альтернативу `useState` для более сложных состояний. Он позволяет вам управлять состоянием через функцию редуктора.

   Пример использования:
   ```javascript
   const [state, dispatch] = useReducer(reducer, initialArg, init);
   ```

5. **useRef()**: Этот хук позволяет вам создать ссылку на элемент.

   Пример использования:
   ```javascript
   const myRef = useRef(null);
   ```

6. **useCallback()**: Этот хук возвращает мемоизированный колбэк.

   Пример использования:
   ```javascript
   const memoizedCallback = useCallback(() => {
      doSomething(a, b);
   }, [a, b]);
   ```

7. **useMemo()**: Этот хук возвращает мемоизированное значение.

   Пример использования:
   ```javascript
   const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);
   ```

[Оглавление - React 🔼](#menureact)

<div  id="react12"></div>

## 12. Что такое React memo и зачем нужен

React memo - это компонент высшего порядка, который будет обновляться только если его предыдущие пропсы не равны новым пропсам. Вторым аргументом принимает функцию для сравнения пропрсов, возращающую Boolean значение, если false – перерисуем.

[Оглавление - React 🔼](#menureact)

<div  id="react13"></div>

## 13. Правила вызова хуков

Хуки нельзя вызвать в циклах/условиях, их можно вызывать только внутри тела компонента. Потому что React полагается на порядок вызова хуков. Т.к хуки должны вызываться в одинаковой последовательности при каждом рендере компонента. Это позволит React правильно кешировать состояние хуков между рендерами. Также в devtools можно увидеть, что каждый хук пронумерован.

[Оглавление - React 🔼](#menureact)

<div  id="react14"></div>

## 14. Как отследить изменение поля объекта в функциональном компоненте?

**Подробнее -** [UseEffect](https://ru.reactjs.org/docs/hooks-reference.html%23useeffect)

  Для этого необходимо воспользоваться хуком useEffect и в массив зависимостей передать поле объекта.

  ---
  В функциональных компонентах React вы можете отследить изменение поля объекта с использованием хука `useEffect`.

Хук `useEffect` принимает два аргумента: функцию-эффект, которую нужно выполнить, и массив зависимостей. Если одна из зависимостей меняется, React будет вызывать функцию-эффект.

Вот пример, в котором `useEffect` используется для отслеживания изменений поля `name` в объекте `person`:

```jsx
import React, { useState, useEffect } from 'react';

function ExampleComponent() {
  const [person, setPerson] = useState({ name: 'John', age: 30 });

  useEffect(() => {
    console.log(`Имя изменилось на ${person.name}`);
  }, [person.name]);

  const handleChangeName = () => {
    setPerson(prevPerson => ({ ...prevPerson, name: 'Jane' }));
  };

  return (
    <div>
      <p>Имя: {person.name}</p>
      <p>Возраст: {person.age}</p>
      <button onClick={handleChangeName}>Изменить имя</button>
    </div>
  );
}

export default ExampleComponent;
```

В этом примере, каждый раз, когда поле `name` в объекте `person` меняется, функция внутри `useEffect` будет вызываться, и в консоль будет выводиться новое имя.

[Оглавление - React 🔼](#menureact)

<div  id="react15"></div>

## 15. Порядок рендера компонентов, и вызова хуков

Порядок рендера const Parent = () => Log синхронный, и выполняется сначала у P потом у C. P замаунтится после того как это сделают дочерние C, изза этого useLayout сначала срабатывает у C. Тоже самое с useEffect.

![img](img/20240511150902.png)

![img](img/20240511150922.png)

Это связано с тем, что алгоритм reconcliation выполняет обход в глубину, и рендеринг компонента завершается только после завершения рендеринга всех его дочерних элементов. В результате корневой компонент в вашем дереве всегда будет завершать рендеринг последним.

[Оглавление - React 🔼](#menureact)

<div  id="react16"></div>

## 16. React.memo для чего нужен и когда использовать?

  **Подробнее -** [memo](https://ru.reactjs.org/docs/react-api.html%23reactmemo)

[Оглавление - React 🔼](#menureact)

  `React.memo` — это функция высшего порядка, которая позволяет обернуть компонент и предотвратить его повторный рендеринг, если пропсы не изменились. Это похоже на `PureComponent` для классовых компонентов, но для функциональных.

`React.memo` делает поверхностное сравнение пропсов. Если пропсы не изменились, он пропускает рендеринг компонента и повторно использует последний результат.

Пример использования `React.memo`:

```jsx
const MyComponent = React.memo(function MyComponent(props) {
  /* рендеринг используя пропсы */
});
```

Используйте `React.memo` тогда, когда у вас есть функциональный компонент, который часто перерендеривается с теми же пропсами. `React.memo` может помочь улучшить производительность, предотвращая ненужные рендеринги. Однако стоит помнить, что использование `React.memo` также имеет свою цену — выполнение поверхностного сравнения пропсов. Это значит, что его использование может быть полезно не во всех случаях, и лучше использовать `React.memo` осознанно, когда вы столкнулись с проблемами производительности, которые он может помочь решить.

[Оглавление - React 🔼](#menureact)

<div  id="react17"></div>

## 17. В каких случаях нужно использовать мемоизацию и зачем

Мемоизация недешевая. Она работает только тогда, когда мы оборачиваем компонент в memo, и когда все props-ы обёрнуты в useMemo и useCallback.
Ее стоит использовать:
- в зависимостях к хукам, чтобы они не вызывались на каждый рендер
- для дорогих вычислений и для высоконагруженных компонентов, например списков.

[Оглавление - React 🔼](#menureact)

<div  id="react18"></div>

## 18. Что такое контекст в реакт, хук useContext

useСontext Принимает объект контекста и возвращает текущее значение контекста для этого контекста, переданного в provider.

Контекст в React — это концепция, которая позволяет вам снабжать дочерние компоненты глобальными данными, независимо от того, насколько глубоко они находятся в дереве компонентов, обернув все provider. Для избежания prop drilling’a.
Context, при изменении значения в провайдере, вызывает рендер для каждого компонента. Redux вызывает рендер только для тех компонентов, которые непосредственно используют измененные значения. Но при использовании Redux, для каждого компонента запускается селектор и сравниваются значения.

[Оглавление - React 🔼](#menureact)

<div  id="react19"></div>

## 19. Что такое кастомные хуки

Кастомные хуки – это просто переиспользуемые функции, которые внутри себя используют встроенные React хуки, для реализации какого-то функционала. Когда React встречает функцию, начинающуюся с "use" внутри компонента, он понимает, что это хук, и обрабатывает его соответствующим образом. Это позволяет поддерживать правильную последовательность вызовов хуков между рендерами.

[Оглавление - React 🔼](#menureact)

<div  id="react20"></div>

## 20. Какие хуки появились React 18, useId, useTransition и тд.

useId – хук который возвращает уникальный id, который можно использовать в атрибутах HTML элементов по типу input, label.

useTransition позволяют помечать некоторые обновления состояния как несрочные.

useSyncExternalStore — добавляет поддержку параллельного чтения для внешних хранилищ;

useDeferredValue - можно обернуть значение и пометить его изменения как менее важные и отложить повторный рендеринг. до тех пор, пока браузер не будет бездействовать.

Concurrent mode – прерываемый рендеринг, для более плавной работы приложений.

[Оглавление - React 🔼](#menureact)

## Хуки

<div  id="react21"></div>

## 21. Как работает useState

**useState** — это хук в React, который используется для добавления состояния в функциональные компоненты. Он принимает начальное значение состояния и возвращает массив, содержащий текущее состояние и функцию для его обновления.

Пример:

```jsx
const [state, setState] = useState(initialState);
```

1. **Аргументы и результат**:
   - **Первый элемент** массива — текущее состояние компонента.
   - **Второй элемент** — функция `setState`, которая используется для обновления состояния.

2. **Ререндеринг**: После вызова `setState`, React повторно рендерит компонент, обновляя отображение данных.

3. **Асинхронность**: `useState` не изменяет состояние мгновенно. Обновление происходит после рендеринга компонента.

4. **Функциональная инициализация**:
   - `useState(compute())` — функция `compute` вызывается при каждом рендере.
   - `useState(() => compute())` — функция вызывается только при первом рендере.

5. **setState**:
   - Используется для изменения состояния и повторного рендеринга компонента.
   - Является асинхронной функцией, поэтому обновления состояния не происходят сразу.

6. **Особенности использования setState**:
   - **Прямое обновление состояния**: Передача нового значения:
     ```jsx
     setCount(5);
     ```
   - **Обновление на основе предыдущего состояния**: Передача функции, которая использует предыдущее состояние:
     ```jsx
     setCount(prevCount => prevCount + 1);
     ```

[Подробнее о useState](https://ru.reactjs.org/docs/hooks-state.html)
[Подробнее о setState](https://ru.reactjs.org/docs/faq-state.html)

[Оглавление - React 🔼](#menureact)

<div  id="react25"></div>

## 25. Как работает useEffect

**useEffect** — это хук в React, который используется для выполнения побочных эффектов в функциональных компонентах. К побочным эффектам относятся такие действия, как запросы на сервер, изменение DOM напрямую, подписки на события и многое другое. Он вызывается после того, как компонент был отрисован браузером.

Основные особенности работы и использования `useEffect`:

1. **Вызов функции эффекта**: Функция, передаваемая в `useEffect`, будет выполнена после того, как браузер обновит DOM. Например:

   ```jsx
   useEffect(() => {
     document.title = `You clicked ${count} times`;
   });
   ```

2. **Зависимости эффекта**: Второй аргумент `useEffect` — это массив зависимостей. Эффект будет выполнен заново, только если одна из зависимостей изменилась с предыдущего рендера. Например:

   ```jsx
   useEffect(() => {
     fetchData(id);
   }, [id]); // эффект будет вызван при изменении 'id'
   ```

   - **Без массива зависимостей**: эффект будет выполняться при каждом рендере.
   - **Пустой массив зависимостей**: эффект выполнится только один раз при маунте компонента.
   - **Массив с элементами**: эффект выполнится при изменении любого элемента в массиве.

3. **Очистка эффекта (Cleanup)**: Если функция, переданная в `useEffect`, возвращает другую функцию, эта возвращаемая функция будет вызвана для очистки перед удалением компонента или перед следующим вызовом эффекта. Например, для отмены таймеров:

   ```jsx
   useEffect(() => {
     const timerID = setInterval(() => tick(), 1000);
     return () => clearInterval(timerID); // очистка при демоунте компонента
   });
   ```

4. **Асинхронность и управление эффектами**: `useEffect` вызывается асинхронно после стадии "painting", что предотвращает блокировку основного потока.

   - Если эффект использует обновление состояния, без контролируемого массива зависимостей, это может вызвать бесконечные рендеры:

     ```jsx
     useEffect(() => {
       setCount(count + 1); // приведет к бесконечному циклу
     });
     ```

Таким образом, `useEffect` позволяет контролировать выполнение побочных эффектов и их очистку, а также управлять их вызовами на основе зависимостей, что делает его ключевым инструментом для работы с внешними данными и состоянием компонента.

[Подробнее о useEffect](https://ru.reactjs.org/docs/hooks-effect.html)

[Оглавление - React 🔼](#menureact)

<div  id="react27"></div>

## 27. Как работает useLayoutEffect, зачем нужен, отличия от useEffect

useLayoutEffect обладает таким же API, как и useEffect, с тем отличием, что он вызывается синхронно, после всех вычислений мутаций в DOM, то есть блокирует отрисовку браузера, в то время как useEffect вызывается асинхронно и не блокирует рендер. (срабатывает до отрисовки в браузере).
Срабатывает когда компоненты уже находятся в virtual dom (можно прочитать/установить различные свойств), но еще не были отрисованы браузером. Вызывается до стадии painting.

(Примеры испоьзования: Измерение размеров DOM элементов; Обновление положения скролла чтобы не было мерцания)

[Оглавление - React 🔼](#menureact)

<div  id="react28"></div>

## 28. useContext для чего нужен и когда использовать?

**Подробнее -** [useContext](https://ru.reactjs.org/docs/hooks-reference.html%23usecontext)

Хук `useContext` в React используется для доступа к значению контекста. Context в React позволяет передавать данные через дерево компонентов без необходимости передавать их через пропсы на каждом уровне.

В основном, это полезно в случаях, когда некоторые данные должны быть доступны для большого количества компонентов в разных уровнях дерева компонентов. Примером может служить тема оформления, текущий выбранный язык, данные пользователя и т.д.

Пример использования `useContext`:

```jsx
// Создание контекста
const ThemeContext = React.createContext('light');

function ThemedButton() {
  // Использование хука useContext для доступа к значению контекста
  const theme = useContext(ThemeContext);
  return <Button theme={theme} />;
}

// Компонент App, который использует ThemedButton
function App() {
  return (
    <ThemeContext.Provider value="dark">
      <ThemedButton />
    </ThemeContext.Provider>
  );
}
```

В этом примере `ThemedButton` может получить текущую тему без необходимости получать её через пропсы от `App`.

Используйте `useContext` тогда, когда вам нужно сделать некоторые данные доступными для большого количества компонентов на различных уровнях в дереве компонентов. Это может упростить ваш код и сделать его более чистым, избегая "проп-дрелинга" (передачи данных через пропсы на каждом уровне).

[Оглавление - React 🔼](#menureact)

<div  id="react29"></div>

## 29. useRef для чего нужен и когда использовать?

  **Подробнее -** [useRef](https://ru.reactjs.org/docs/hooks-reference.html%23useref)

[Оглавление - React 🔼](#menureact)

  Хук `useRef` в React используется для создания ссылок на элементы.

В отличие от состояния, изменения `ref` не вызывают повторный рендеринг компонента. Это делает `ref` удобными для сохранения значений, которые могут изменяться во время жизненного цикла компонента, но не вызывают повторный рендеринг.

`useRef` часто используется для доступа к DOM-элементам и их методам. Например, вы можете использовать `ref`, чтобы установить фокус на определенном поле ввода.

```jsx
import React, { useRef } from 'react';

function TextInputWithFocusButton() {
  const inputEl = useRef(null);
  const onButtonClick = () => {
    // `current` указывает на подключенный текстовый ввод
    inputEl.current.focus();
  };
  return (
    <>
      <input ref={inputEl} type="text" />
      <button onClick={onButtonClick}>Установить фокус на поле ввода</button>
    </>
  );
}

export default TextInputWithFocusButton;
```

`useRef` также можно использовать для хранения любых изменяемых значений, аналогичных instance variables в классовых компонентах. Например, для отслеживания предыдущего состояния или пропсов.

Используйте `useRef`, когда вам нужно получить прямой доступ к DOM-элементу (например, для установки фокуса или измерения элемента) или когда вам нужно сохранить изменяемое значение, которое не вызывает перерендеринг.

[Оглавление - React 🔼](#menureact)

<div  id="react31"></div>

## 31. Как работает useMemo

**Подробнее -** [useMemo](https://ru.reactjs.org/docs/hooks-reference.html%23usememo)

принимает колбэк и позволяет мемоизировать возвращаемое значение.

`useMemo` - это React хук, который используется для мемоизации сложных функций, то есть для сохранения результатов функции, чтобы избежать повторного её выполнения при следующих рендерах, если входные данные не изменились.

`useMemo` принимает два аргумента:
1. Функция, результат которой мы хотим мемоизировать.
2. Массив зависимостей, по которому React определит, нужно ли заново выполнять функцию или же можно использовать сохраненный результат.

Пример использования `useMemo`:
```jsx
const expensiveCalculation = useMemo(() => {
    return performExpensiveCalculation(a, b);
}, [a, b]);
```
В этом примере `performExpensiveCalculation` будет вызываться только тогда, когда изменяются значения `a` или `b`. В противном случае React будет использовать сохраненный результат, что позволит увеличить производительность приложения.

`useMemo` следует использовать, когда:
- Вы работаете с большими массивами или объектами и хотите избежать лишних рендеров и пересчетов.
- Вы выполняете сложные вычисления, которые занимают много времени.
- Вы передаете коллекции в компоненты и хотите предотвратить ненужные ререндеры из-за того, что новый объект создается при каждом рендере.

Однако следует помнить, что `useMemo` не всегда приводит к улучшению производительности. Иногда затраты на мемоизацию (хранение предыдущих результатов и сравнение аргументов) могут быть больше, чем преимущества от ее использования. Поэтому его следует использовать осознанно.

[Оглавление - React 🔼](#menureact)

<div  id="react32"></div>

## 32. Как работает useCallback

**Подробнее -** [useCallback](https://ru.reactjs.org/docs/hooks-reference.html%23usecallback)

useCallback позволяет мемоизировать переданный колбек, то есть при каждом рендере, ссылка на функцию, будет неизменна. Ссылка будет новой только, когда изменится одна из переданных зависимостей. Стоит юзать только когда передаем через пропсы другому компоненту, использующему React.memo, или в зависимости другим хукам, наример useffect.

Хук `useCallback` в React используется для мемоизации функций с целью оптимизации производительности.

`useCallback` принимает два аргумента:
1. Функция, которую мы хотим мемоизировать.
2. Массив зависимостей, на основе которых React определяет, когда нужно пересоздавать функцию.

Когда массив зависимостей остается неизменным, React возвращает сохраненную версию функции, что предотвращает её ненужное пересоздание.

Пример использования `useCallback`:

```jsx
const memoizedCallback = useCallback(() => {
    doSomething(a, b);
}, [a, b]);
```

В этом примере функция `doSomething(a, b)` будет пересоздана только в случае, если `a` или `b` изменятся.

`useCallback` стоит использовать в следующих случаях:

1. Когда вы передаете функцию в оптимизированный дочерний компонент, который полагается на сравнение ссылок для предотвращения ненужных рендеров (например, компонент, обернутый в `React.memo`).
2. Когда вы передаете функцию в хук, который принимает функцию и массив зависимостей, как, например, `useEffect`, `useCallback` или `useMemo`.
3. Когда вы используете функцию в большом компоненте, и эта функция пересоздается при каждом рендере.

Однако стоит отметить, что ненужное использование `useCallback` может привести к ухудшению производительности, поскольку создание мемоизированной функции также требует ресурсов. Поэтому `useCallback` следует использовать только тогда, когда это действительно необходимо.

[Оглавление - React 🔼](#menureact)

<div  id="react34"></div>

## 34. Как работает useReducer

Хук useReducer(reducer, initialState) принимает 2 аргумента: чистую функцию reducer которая определяет, как обновляется состояние и начальное состояние. И возвращает массив с: текущим состоянием и функцией dispatch.

[Оглавление - React 🔼](#menureact)

## Работа с DOM

<div  id="react35"></div>

## 35. Как отрисовать массив элементов

  **Подробнее -** [Списки и ключи](https://ru.reactjs.org/docs/lists-and-keys.html)

Для того чтобы отрисовать список элементов используется функция массивов map, внутри которой мы пишем jsx разметку, при этом React требует указывать ключ key для каждого элемента итерации. Ключи помогают React идентифицировать, какие элементы были изменены, добавлены или удалены.

Ключи должны быть заданы элементам внутри массива, чтобы предоставить элементам постоянный идентификатор

пример:
```jsx
const numbers = [1, 2, 3, 4, 5];

return (
  <ul>
    {numbers.map((el, index) =>
      <li key={index}>{el}</li>
    )}
  </ul>
);
```
В этом коде для каждого числа из массива `numbers` создается элемент списка `<li>`.
В примере выше используется `index` массива в качестве `key`, однако это может привести к проблемам с производительностью и состоянием компонента при изменении порядка или количества элементов. В идеале `key` должен быть уникальным и стабильным идентификатором, таким как ID из базы данных.

[Оглавление - React 🔼](#menureact)

<div  id="react36"></div>

## 36. Как отрисовать блок по условию?

**Подробнее -** [Условный рендеринг](https://ru.reactjs.org/docs/conditional-rendering.html)

  В React можно отрисовать блок по условию с использованием условных операторов JavaScript, таких как `if`, `if-else` или тернарный оператор. Ниже приведены примеры обоих подходов.

1. Использование тернарного оператора:

```jsx
function ExampleComponent({ condition }) {
  return (
    <div>
      {condition ? <div>Это отрендерится, если condition истинно</div> : <div>Это отрендерится, если condition ложно</div>}
    </div>
  );
}
```

2. Использование логического оператора "&&":

```jsx
function ExampleComponent({ condition }) {
  return (
    <div>
      {condition && <div>Этот блок отрендерится только если condition истинно</div>}
    </div>
  );
}
```

В обоих этих примерах `condition` - это prop, который передается в компонент `ExampleComponent`. Если `condition` истинно, то будет отрендерен соответствующий блок. Если `condition` ложно, то блок не будет отрендерен.

[Оглавление - React 🔼](#menureact)

<div  id="react37"></div>

## 37. Как получить доступ к дом элементу в React

  **Подробнее –** [refs](https://ru.reactjs.org/docs/refs-and-the-dom.html)

Для доступа к DOM-элементам в React используется хук `useRef`.

`useRef` возвращает изменяемый ref-объект, свойство `.current` которого инициализируется переданным аргументом (`initialValue`). Возвращённый объект будет сохраняться в течение всего времени жизни компонента.

Пример использования `useRef` для доступа к DOM-элементу:

```jsx
import React, { useRef } from 'react';

function ExampleComponent() {
  const inputRef = useRef(null);

  const focusInput = () => {
    // `current` указывает на смонтированный текстовый элемент `input`
    inputRef.current.focus();
  };

  return (
    <>
      <input ref={inputRef} type="text" />
      <button onClick={focusInput}>Установить фокус на поле ввода</button>
    </>
  );
}

export default ExampleComponent;
```

В этом примере, когда вы нажимаете кнопку, фокус устанавливается на текстовое поле ввода. Важно помнить, что в React вы должны использовать этот паттерн осторожно и только в тех случаях, когда не можете выполнить задачу иначе. Обычно вы должны стараться избегать прямого взаимодействия с DOM.

[Оглавление - React 🔼](#menureact)

<div  id="react38"></div>

## 38. Что такое порталы `Portal` в React?

Порталы позволяют рендерить дочерние элементы в DOM-узел, который находится вне DOM-иерархии родительского компонента.

```js
ReactDOM.createPortal(child, container)
```

Первый аргумент (child) — это любой React-компонент, который может быть отрендерен, такой как элемент, строка или фрагмент. Следующий аргумент (container) — это DOM-элемент.

Типовой случай применения порталов — когда в родительском компоненте заданы стили overflow: hidden или z-index, но вам нужно чтобы дочерний элемент визуально выходил за рамки своего контейнера. Например, диалоги, всплывающие карточки и всплывающие подсказки.

[Оглавление - React 🔼](#menureact)

<div  id="react39"></div>

## 39. Для чего нужны ключи `key` в списках?

  **Подробнее -** [Ключи](https://ru.reactjs.org/docs/lists-and-keys.html%23keys)

Key - это атрибут, который нужно использовать при создании списков из элементов массива.

Проп key помогает React определять, какие элементы массива подверглись изменениям, были добавлены или удалены.

Он должен быть уникальным, их необходимо указывать, чтобы React мог сопоставлять элементы массива с течением времени, по дефолту будут использоваться index.

Использовать индексы в качестве ключей не рекомендуется, если порядок расположения элементов может измениться, потому что это может повлечь за собой неожиданное поведение состояний.

При изменении ключа компонент демонтируется и монтируется заново.

**Что будет если в качестве key использовать индекс массива?**

Если удалить или добавить что-то по середине или отсортировать. key останется точно таким же, что и прежде, и React предполагает, что DOM-элемент отображает тот же компонент, что и прежде. Но это уже не так.

[Оглавление - React 🔼](#menureact)

<div  id="react40"></div>

## 40. Как работает проп `children`?

Проп `children` в React представляет собой специальный проп, который позволяет передавать содержимое (дочерние элементы) в компонент. Он используется для вложенных элементов и текста, которые передаются между открывающим и закрывающим тегами компонента.

Пример использования пропа `children`:

```jsx
function MyComponent({ children }) {
  return <div>{children}</div>;
}

// Использование компонента и передача содержимого в виде дочерних элементов
<MyComponent>
  <h1>Заголовок</h1>
  <p>Некоторый текст</p>
</MyComponent>
```

В приведенном выше примере компонента `MyComponent` содержимое, заключенное между тегами `<MyComponent>` и `</MyComponent>`, будет передано в компонент через проп `children`. В данном случае, дочерними элементами будут `<h1>Заголовок</h1>` и `<p>Некоторый текст</p>`. Внутри компонента `MyComponent` мы можем использовать `children` для рендеринга этого содержимого внутри других элементов или компонентов.

Проп `children` может содержать любые элементы React, включая другие компоненты, строки, числа и т. д. Это позволяет гибко использовать компоненты и передавать им содержимое внутри.

Кроме использования в качестве дочерних элементов, проп `children` также может быть использован для передачи функции-коллбэка в компоненты, которые ожидают его в качестве пропа. Это позволяет динамически взаимодействовать с содержимым компонента.

```jsx
function MyComponent({ children }) {
  return <div>{children('Привет, мир!')}</div>;
}

<MyComponent>
  {(message) => <p>{message}</p>}
</MyComponent>
```

В этом примере, `children` является функцией, которая вызывается внутри компонента `MyComponent` с аргументом `'Привет, мир!'`. Мы передаем функцию в виде дочернего элемента `<MyComponent>`, которая будет вызвана и внутри которой мы можем рендерить дополнительные элементы или выполнять другие действия на основе переданного сообщения.

[Оглавление - React 🔼](#menureact)

<div  id="react41"></div>

## 41. Зачем нужен хок `forwardRef`

forwardRef - это функция, которая принимает функциональный компонент и возвращает новый функциональный компонент, который может иметь атрибут ref. Если просто передать ref в компонент не использующий forwardRef, то будет ошибка.

[Оглавление - React 🔼](#menureact)

<div  id="react42"></div>

## 42. Хук `useImperativeHandle`

useImperativeHandle принимает ref переданный от родительского компонента, Вторым аргументом принимает функцию (init), которая возвращает объект, что будет записан в ref. Позволяет записывать в ref любые данные изнутри функционального компонента.

[Оглавление - React 🔼](#menureact)


## Жизненный цикл компонентов

<div  id="react43"></div>

## 43. Методы жизненного цикла компонента

**Подробнее -** [Жизненный цикл](https://ru.react.js.org/docs/react-component.html)

  Существует четыре различных этапа жизненного цикла компонента React:

1. **Инициализация**: На этом этапе компонент React готовит установку начального состояния и параметров по умолчанию.

2. **Монтирование (Mounting)**: Компонент React готов для монтирования в DOM браузера. Этот этап охватывает методы жизненного цикла componentWillMount и componentDidMount.

3. **Обновление (Updating)**: На этом этапе компонент обновляется двумя способами, отправляя новые свойства и обновляя состояние. Этот этап охватывает методы жизненного цикла shouldComponentUpdate, componentWillUpdate и componentDidUpdate.

4. **Размонтирование (Unmounting)**: На этом последнем этапе компонент не нужен и отключается из DOM браузера. Этот этап включает метод жизненного цикла componentWillUnmount.

[Оглавление - React 🔼](#menureact)

<div  id="react44"></div>

## 44. Жизненный цикл компонента и методы ЖЦ в классах, порядок вызова

ЖИЗНЕННЫЙ ЦИКЛ
- componentDidMount() вызывается после монтирования компонента в DOM-дерево. подходящее место для подпискок, запросов на сервер.
- componentDidUpdate(prevProps, prevState,) вызывается сразу после обновления. Этот метод не вызывается при первоначальной отрисовке. Это также подходит для выполнения запросов, если нужно сделать запрос при изменении текущих свойств.
- componentWillUnmount() вызывается перед размонтированием компонента. Выполните необходимую очистку в этом методе, такую как отмена таймеров, сетевых запросов или очистка любых подписок, созданных в componentDidMount().
- shouldComponentUpdate(nextProps, nextState) вызывается перед отрисовкой при получении новых свойств или состояний. Значение по умолчанию равно true.
- getDerivedStateFromProps вызывается непосредственно перед вызовом метода render(), как при начальном монтировании, так и при последующих обновлениях. Он должен вернуть объект для обновления состояния или null, чтобы ничего не обновлять.

- Инициализация – компонент готовит установку начального состояния и параметров по умолч.
- Монтирование – компонент готов для монтирования в ДОМ дерево браузера willMount, didMount.
- Обновление – обновление состояния компонента, didUpdate, willUpdate, shouldUpdate.
- Размонтирование – компонент удаляется из ДОМ дерева браузера

![img](img/20240511151412.png)

[Оглавление - React 🔼](#menureact)

<div  id="react45"></div>

## 45. Как отследить демонтирование функционального компонента?

**Подробнее -** [useEffect со сбросом](https://ru.reactjs.org/docs/hooks-effect.html%23effects-with-cleanup)

Часто эффекты создают ресурсы, которые необходимо очистить (или сбросить) перед тем, как компонент покидает экран, например, подписку или идентификатор таймера. Чтобы сделать это, функция, переданная в useEffect, может вернуть функцию очистки. Функция очистки запускается до удаления компонента из пользовательского интерфейса, чтобы предотвратить утечки памяти. Кроме того, если компонент рендерится несколько раз (как обычно происходит), предыдущий эффект очищается перед выполнением следующего эффекта.

```jsx
useEffect(() => {
  // Действия, которые выполняются при монтировании компонента
  const timerID = setInterval(() => {
    console.log('Таймер работает');
  }, 1000);

  // Функция очистки, которая выполняется при демонтировании компонента
  return () => {
    clearInterval(timerID);
    console.log('Компонент был демонтирован');
  };
}, []); // Пустой массив зависимостей означает, что эффект запускается только при монтировании и очищается при демонтировании
```

[Оглавление - React 🔼](#menureact)

## Оптимизация

<div  id="react46"></div>

## 46. Что такое React `lazy и Suspense`

**`React.lazy`** и **`Suspense`** — это инструменты, которые позволяют загружать компоненты в React лениво (lazy loading), что помогает улучшить производительность приложения, загружая компоненты только тогда, когда они действительно необходимы.

### 1. **`React.lazy`**

**`React.lazy`** — это функция, которая позволяет загружать компоненты динамически и только тогда, когда они требуются. Это особенно полезно для больших приложений, где часть компонентов используется только в определённых сценариях или на определённых страницах. С помощью ленивой загрузки можно уменьшить размер бандла, загружаемого при начальной загрузке страницы, и таким образом ускорить загрузку.

### Как работает `React.lazy`:

```jsx
import React, { lazy, Suspense } from 'react';

// Лениво загружаемый компонент
const LazyComponent = lazy(() => import('./LazyComponent'));

const App = () => {
  return (
    <div>
      <h1>Пример использования React.lazy</h1>
      <Suspense fallback={<div>Загрузка...</div>}>
        <LazyComponent />
      </Suspense>
    </div>
  );
};

export default App;
```

### Объяснение:
- **`lazy(() => import('./LazyComponent'))`**: Это способ ленивой загрузки компонента. Компонент `LazyComponent` будет загружен только тогда, когда он появится в DOM, а не во время начальной загрузки страницы.
- **Dynamic Import**: Внутри `lazy` используется синтаксис динамического импорта ES6 (`import()`), который возвращает промис. Когда промис разрешается, загружается компонент.

### 2. **`Suspense`**

**`Suspense`** — это компонент, который работает вместе с `React.lazy`, чтобы отобразить запасной контент (например, индикатор загрузки) во время загрузки ленивого компонента. Пока лениво загружаемый компонент не загружен, `Suspense` показывает запасной UI, указанный в его свойстве `fallback`.

### Как работает `Suspense`:

```jsx
<Suspense fallback={<div>Загрузка...</div>}>
  <LazyComponent />
</Suspense>
```

- **`fallback`**: Это свойство, принимающее компонент или элемент, который будет отображаться во время ожидания загрузки ленивого компонента. Как только компонент загружен, отображается реальный контент.

### Пример использования `React.lazy` и `Suspense`:

```jsx
import React, { lazy, Suspense } from 'react';

// Лениво загружаемый компонент
const UserProfile = lazy(() => import('./UserProfile'));

const App = () => {
  return (
    <div>
      <h1>Добро пожаловать!</h1>
      {/* Отображаем индикатор загрузки, пока компонент загружается */}
      <Suspense fallback={<div>Загрузка профиля...</div>}>
        <UserProfile />
      </Suspense>
    </div>
  );
};

export default App;
```

### Объяснение:
- В этом примере `UserProfile` будет загружен только тогда, когда его нужно будет отобразить.
- Пока компонент `UserProfile` загружается, пользователю показывается текст "Загрузка профиля...".
- Как только компонент загружается, он заменяет fallback-контент.

### Преимущества использования `React.lazy` и `Suspense`:
1. **Оптимизация производительности**: Снижается размер начальной загрузки приложения, так как не все компоненты загружаются сразу.
2. **Улучшение пользовательского опыта**: Вы можете отображать индикаторы загрузки, чтобы пользователь знал, что контент загружается.
3. **Динамическая загрузка**: Компоненты загружаются только тогда, когда они необходимы, что экономит ресурсы.

### Заключение:

**`React.lazy`** и **`Suspense`** предоставляют мощные инструменты для улучшения производительности приложений, позволяя загружать компоненты динамически только тогда, когда они нужны. Это помогает ускорить загрузку страницы и снизить нагрузку на сеть, особенно в крупных приложениях.

[Оглавление - React 🔼](#menureact)

<div  id="react47"></div>

## 47. Что такое батчинг, его плюсы

Батчингом в React называют процесс группировки нескольких вызовов обновления состояния в один этап ререндера. Это положительно сказывается на производительности. В реакт 18 здесь будет 1 ререндер, в остальных версиях 2:

const OnClick = () => {
	setState1()
	setState2()
}

![img](img/20240511151040.png)

![img](img/20240511151055.png)

[Оглавление - React 🔼](#menureact)

<div  id="react49"></div>

## 49. Причины `перерисовки в React`

Причины перерисовки react –
- изменение props,
- изменение состояния,
- изменение контекста,
- метод forceUpdate в классах,
- ререндер родительского компонента (вызовет ререндер дочерних),
- изменение key

[Оглавление - React 🔼](#menureact)

<div  id="react50"></div>

## 50. Что такое `Виртуализация` и зачем нужна

Виртуализация – позволяет рендерить только те элементы, которые видны на экране. Рендер предполагает создание множества объектов в DOM и в Virtual DOM, все это нужно хранить в памяти, рендерить в браузере, отслеживать изменения.

[Оглавление - React 🔼](#menureact)

<div  id="react51"></div>

## 51. Что такое `Throttling`

links: - https://walborn.notion.site/Throttling-e5101dd0b1b344de9f1f710d127a1b0c

**Throttling** (ограничение) — это техника, используемая для ограничения частоты вызова функций или обработки запросов. Throttling контролирует, как часто функция может быть вызвана в определённый промежуток времени. Это полезно в сценариях, где важно избегать перегрузки системы или отправки слишком большого количества запросов за короткий период времени.

### Принцип работы:

Throttling позволяет вызывать функцию не чаще, чем определённое количество раз за установленный интервал времени. Если функция вызывается чаще, чем разрешено, остальные вызовы игнорируются или откладываются до следующего разрешённого момента.

### Пример использования:

Throttling часто применяется в таких сценариях, как:
1. **Работа с событиями UI** (например, обработка прокрутки или изменения размера окна), чтобы не вызывать слишком много событий и не перегружать интерфейс.
2. **Ограничение API-запросов** для избежания превышения лимитов запросов или перегрузки сервера.
3. **Оптимизация ресурсов** при частом изменении данных или отправке запросов на сервер.

### Пример на JavaScript:

```js
function throttle(func, limit) {
  let inThrottle;
  return function() {
    const args = arguments;
    const context = this;
    if (!inThrottle) {
      func.apply(context, args);
      inThrottle = true;
      setTimeout(() => (inThrottle = false), limit);
    }
  };
}

// Пример использования:
window.addEventListener('resize', throttle(() => {
  console.log('Resizing...');
}, 1000));
```

В этом примере функция `throttle` позволяет вызвать функцию только один раз за 1000 миллисекунд, даже если событие `resize` происходит намного чаще.

### Различие с **Debouncing**:

- **Throttling**: Позволяет вызовы функции через регулярные интервалы времени, даже если события происходят постоянно.
- **Debouncing**: Откладывает выполнение функции до тех пор, пока события не прекратятся, и вызовет функцию только один раз в конце.

### Применение в реальных ситуациях:

1. **API-запросы**:
   Например, чтобы не отправлять слишком много запросов к внешнему API за короткое время, можно использовать Throttling, чтобы ограничить число запросов. Это полезно для соблюдения лимитов API и предотвращения блокировок.

2. **События прокрутки или изменения размеров окна**:
   Обработка событий, таких как `scroll` или `resize`, может происходить слишком часто, что может повлиять на производительность. Throttling помогает оптимизировать выполнение, ограничив частоту вызова функции обработки.

Таким образом, Throttling — это важная техника оптимизации, помогающая избежать перегрузки ресурсов и улучшить производительность приложений.-

[Оглавление - React 🔼](#menureact)

<div  id="react52"></div>

## 52. Что такое `Debounce`

links: - https://walborn.notion.site/Debounce-73df76233a4d42dca0ce5ce66c20a4d3

**Debounce** (устранение дребезга) — это техника программирования, используемая для того, чтобы откладывать выполнение функции до тех пор, пока не прекратятся частые вызовы. Иными словами, функция будет вызвана только после того, как пройдёт определённое время с момента последнего вызова. Это особенно полезно, когда важно предотвратить чрезмерное количество вызовов функции за короткий промежуток времени.

### Принцип работы:

Debounce работает так: если функция вызывается несколько раз подряд, она не будет выполнена до тех пор, пока не пройдёт заданный промежуток времени (например, 300 миллисекунд) с последнего вызова. Если за это время функция вызывается снова, таймер сбрасывается, и отсчёт начинается заново.

### Пример сценариев, где полезен Debounce:
1. **Поле поиска с автоподсказками**: Когда пользователь вводит текст в поле поиска, debounce предотвращает отправку запроса на сервер при каждом нажатии клавиши, ожидая, пока пользователь завершит ввод.
2. **Изменение размера окна (resize)**: Для того чтобы избежать лишней обработки, когда пользователь изменяет размер окна, выполнение функции может быть отложено до момента завершения действия.
3. **Проверка формы**: Debounce может быть использован для валидации данных формы только после того, как пользователь закончил ввод данных.

### Пример на JavaScript:

```js
function debounce(func, delay) {
  let timeoutId;
  return function(...args) {
    clearTimeout(timeoutId);
    timeoutId = setTimeout(() => {
      func.apply(this, args);
    }, delay);
  };
}

// Пример использования
window.addEventListener('resize', debounce(() => {
  console.log('Window resized');
}, 300));
```

В этом примере обработчик изменения размера окна будет вызван только через 300 миллисекунд после того, как пользователь закончит изменять размер окна. Если он продолжает изменять размер, функция не будет выполнена до тех пор, пока процесс не завершится.

### Различие между **Throttle** и **Debounce**:
- **Throttle** ограничивает выполнение функции через определённые интервалы времени (например, один вызов функции раз в 1000 миллисекунд), даже если события продолжают происходить.
- **Debounce** откладывает выполнение функции до тех пор, пока не прекратятся частые вызовы. Она выполняется только после того, как действие завершилось.

### Пример использования в React:

Допустим, у нас есть компонент для поля поиска, где каждый ввод символа запускает поиск по API, но мы не хотим отправлять запросы на сервер при каждом нажатии клавиши. В этом случае можно использовать debounce.

### Пример debounce в React:

```jsx
import React, { useState } from 'react';

// Функция для создания debounce
function debounce(func, delay) {
  let timeoutId;
  return function(...args) {
    if (timeoutId) clearTimeout(timeoutId);
    timeoutId = setTimeout(() => {
      func.apply(this, args);
    }, delay);
  };
}

const SearchInput = () => {
  const [query, setQuery] = useState('');

  const handleSearch = debounce((value) => {
    console.log('Searching for:', value);
    // Здесь можно отправить запрос на сервер с value
  }, 500); // 500 миллисекунд задержки

  const handleInputChange = (event) => {
    const value = event.target.value;
    setQuery(value);
    handleSearch(value); // Вызываем debounced функцию
  };

  return (
    <div>
      <input
        type="text"
        value={query}
        onChange={handleInputChange}
        placeholder="Search..."
      />
    </div>
  );
};

export default SearchInput;
```

### Описание:
1. **Debounce функция**: Мы создаём `debounce` функцию, которая принимает другую функцию (`handleSearch`) и задержку (500 миллисекунд).
2. **Компонент `SearchInput`**:
   - Мы отслеживаем значение ввода через `useState`.
   - При каждом изменении значения вводимого текста вызывается `handleSearch`, которая запускает поиск только через 500 миллисекунд после завершения ввода (когда пользователь перестанет печатать).
3. **Запрос на сервер**: Логика запроса к серверу (`console.log('Searching for:', value)`) выполнится только тогда, когда пользователь прекратит ввод на 500 миллисекунд.

### Преимущества использования Debounce:
- **Оптимизация**: Снижает нагрузку на сервер или интерфейс, предотвращая выполнение ненужных запросов при каждом вводе.
- **Улучшение UX**: Повышает отзывчивость интерфейса, так как запросы выполняются только тогда, когда это действительно необходимо.

Таким образом, **debounce** — это полезная техника для управления частотой вызовов функций, особенно когда важно выполнять действия только после того, как пользователь закончил свои действия.

[Оглавление - React 🔼](#menureact)

## Управление состоянием

<div  id="react53"></div>

## 53. Что такое `State менеджер`?

State менеджер решает несколько проблем, во первых это хорошая практика, отделять данные и логику по работе с ними от компонентов, во вторых, если использовать локальное состояние и передавать его из компоненты в компонент код становится запутанным, поскольку вложенность компонентов может быть большой. Имея глобальное хранилище, мы можем обращаться к нему с любого компонента и получать\изменять данные. Вместе с React используют чаще всего либо Redux, либо MobX.

[Оглавление - React 🔼](#menureact)

<div  id="react54"></div>

## 54. `Flux-архитектура`, Redux и MobX: Что такое Flux - архитектура? Какие сущности она имеет?

Flux - это архитектурный подход или паттерн проектирования для построения пользовательских интерфейсов, разработанный в Facebook вместе с библиотекой React.

Центральная идея Flux-архитектуры - управление потоком данных в приложении в одном направлении. В отличие от двусторонней привязки данных (two-way data binding), используемой во многих других фреймворках, Flux обеспечивает однонаправленный поток данных, который делает поток данных более предсказуемым.

Вот основные сущности, которые присутствуют в архитектуре Flux:

1. **Действия (Actions)** - Это простые объекты, содержащие новые данные и тип события. Действия создаются и отправляются в диспетчер с помощью создателей действий (action creators).

2. **Диспетчер (Dispatcher)** - Центральный хаб, который управляет всеми потоками данных в приложении Flux. Каждое действие, переданное в диспетчер, распространяется на все хранилища.

3. **Хранилища (Stores)** - Компоненты, которые содержат состояние приложения и логику его изменения. В отличие от моделей в MVC-архитектуре, которые представляют объекты в вашем приложении, хранилища в Flux представляют собой больше всего состояние приложения и управляют его обновлением.

4. **Представления (Views)** - Компоненты React, которые слушают изменения в хранилищах и перерисовываются, когда состояние в хранилищах меняется. Это обеспечивает синхронизацию представлений с текущим состоянием приложения.

Пример архитектуры Flux: пользователь нажимает кнопку в представлении, что вызывает действие. Это действие передается в диспетчер, который затем отправляет действие во все хранилища. Хранилища обрабатывают действие и обновляют свое состояние, если это необходимо. Когда состояние хранилища обновляется, он генерирует событие изменения, на которое реагирует представление, обновляя себя в соответствии с новым состоянием.

Redux и MobX - это библиотеки, которые предоставляют альтернативные реализации идеи Flux. Redux сохраняет ключевые аспекты Flux, но значительно упрощает структуру, сокращая количество ключевых сущностей до трех: Store, Action и Reducer. Redux использует одно хранилище для всего состояния приложения и использует чистые функции (reducers) для обновления этого состояния.

MobX, с другой стороны, предлагает более декларативный и автоматический подход к управлению состоянием. Вместо явного определения действий и редукторов, MobX позволяет вам работать непосредственно с обновляемыми значениями, и он автоматически отслеживает, какие компоненты должны быть обновлены на основе тех данных, которые они используют.

Обе библиотеки имеют свои преимущества и отлично подходят для разных сценариев использования. Выбор между ними обычно определяется предпочтениями команды, конкретными требованиями проекта и личными предпочтениями разработчиков.

[Оглавление - React 🔼](#menureact)

<div  id="react55"></div>

## 55. что такое `Redux` и FLUX паттерн

`Redux` - это стейт менеджер для хранения состояния приложения, основанный на паттерне проектирования Flux. принципы Redux: единственный источник истины (store). Состояние только для чтения (единственный способ обновить состояние – action). Изменения вносятся с помощью чистых функций (reducers)

[Оглавление - React 🔼](#menureact)

<div  id="react56"></div>

## 56. `Redux vs Context` плюсы и минусы

REDUX:
+ поддержка асинхронных экшнов и middleware, такие как saga, thunk и т.д;
+ явное отделение бизнес-логики от UI, более удобно писать код;
+ devtools для отслеживания всех обновлений состояния.
+ более оптимизирован в отличии от context, есть reselect, entityAdapter для нормализации.
Минусы
- вес npm пакета
- приходится писать бойлерплейт код

 CONTEXT:
 + не нужно скачивать npm пакеты
 + позволяет избавиться от prop-drilling и создать глобальное состояние
 Минусы
 - оптимизация, при изменении состояния ререндерит всех потребителей контекста
 - не такое явное отделение логики от UI
 - нет поддержки middlware и асинхронных экшнов, нет devtools

 Отличия от MOBX: мобх на классах, компоненты нужно оборачивать в обсервер, редукс иммутабельный, имеет мидлвары саги, санки.

[Оглавление - React 🔼](#menureact)

<div  id="react57"></div>

## 57. Что такое `store в redux`

Store — это объект, который соединяет эти части вместе. Стор берет на себя следующие задачи: содержит состояние приложения (application state); предоставляет доступ к состоянию с помощью getState(); предоставляет возможность обновления состояния с помощью dispatch(action)

[Оглавление - React 🔼](#menureact)

<div  id="react58"></div>

## 58. Что такое `action в redux`

**Подробнее -** [actions](https://redux.js.org/faq/actions%23actions)

  В Redux **экшен (action)** - это обычный JavaScript объект, который описывает произошедшее событие или изменение. Экшен - единственный способ передать данные из приложения в хранилище Redux.

У каждого экшена должно быть свойство `type`, которое указывает на тип произошедшего действия. Это обычно строка и важна для того, чтобы редьюсер мог определить, каким образом изменить состояние в ответ на этот экшен. Экшены могут также содержать дополнительные данные в поле `payload` или других полях.

Пример объекта экшена:

```javascript
{
  type: 'ADD_TODO',
  payload: {
    id: 1,
    text: 'Learn Redux'
  }
}
```

Чтобы изменить состояние с помощью экшена, нужно сначала **отправить** (dispatch) этот экшен. Отправка экшена осуществляется с помощью функции `dispatch()`, которую предоставляет Redux. После отправки экшена, он проходит через все редьюсеры в хранилище Redux. Каждый редьюсер проверяет тип экшена и решает, нужно ли обновить свое состояние в ответ на этот экшен.

Вот пример того, как можно отправить экшен и изменить состояние:

```javascript
// создание экшена
let action = {
  type: 'ADD_TODO',
  payload: {
    id: 1,
    text: 'Learn Redux'
  }
};

// отправка экшена
dispatch(action);
```

Этот код создает экшен с типом `ADD_TODO` и отправляет его с помощью функции `dispatch()`. После этого редьюсеры в хранилище Redux реагируют на этот экшен и обновляют состояние соответствующим образом.

[Оглавление - React 🔼](#menureact)

<div  id="react59"></div>

## 59. Что такое `reducer в redux`

**Подробнее -** [reducers](https://redux.js.org/tutorials/fundamentals/part-3-state-actions-reducers%23writing-reducers)

В Redux, **редьюсер** - это чистая функция, которая принимает текущее состояние приложения (state) и действие (action), а затем возвращает новое состояние. Редьюсеры являются ключевым механизмом в Redux, и именно они отвечают за обновление состояния.

Редьюсер принимает два параметра:

1. **state**: Текущее состояние приложения или часть состояния, которую редьюсер контролирует. Важно отметить, что редьюсер никогда не изменяет этого состояния напрямую. Вместо этого, он создает и возвращает новое состояние на основе входящего состояния и действия.

2. **action**: Объект действия, который описывает, что произошло. Объект действия должен содержать поле `type`, которое указывает на тип произошедшего действия. Он также может содержать дополнительные данные в поле `payload` или других полях, которые затем могут быть использованы редьюсером для обновления состояния.

Пример редьюсера в Redux:

```javascript
function counterReducer(state = 0, action) {
  switch (action.type) {
    case 'INCREMENT':
      return state + 1;
    case 'DECREMENT':
      return state - 1;
    default:
      return state;
  }
}
```

В этом примере, в зависимости от типа действия (`INCREMENT` или `DECREMENT`), редьюсер обновляет состояние, увеличивая или уменьшая его на единицу. Если тип действия не известен, редьюсер просто возвращает текущее состояние без изменений.

[Оглавление - React 🔼](#menureact)

<div  id="react60"></div>

## 60. Что такое `dispatch в redux`

dispatch() – это метод, который принимает экшн и позволяет изменить состояние. Компонент делает хранилище Redux доступным для любых вложенных компонентов, которым требуется доступ к хранилищу Redux.

[Оглавление - React 🔼](#menureact)

<div  id="react63"></div>

## 63. Асинхронные actions в redux с помощью `thunk`

**Подробнее -** [redux thunk](https://habr.com/ru/post/483314/)

В Redux среда выполнения `middleware` обрабатывает более сложную асинхронную логику. Один из наиболее распространенных middleware для Redux - это `redux-thunk`, который позволяет создавать асинхронные actions.

Обычные действия в Redux - это объекты, которые синхронно отправляются в хранилище с помощью `dispatch()`. Однако, когда вы используете `redux-thunk`, ваши actions могут стать функциями, что позволяет их вызывать асинхронно.

Вот базовый пример асинхронного action, который использует `redux-thunk`:

```javascript
// action types
const FETCH_DATA_REQUEST = 'FETCH_DATA_REQUEST';
const FETCH_DATA_SUCCESS = 'FETCH_DATA_SUCCESS';
const FETCH_DATA_FAILURE = 'FETCH_DATA_FAILURE';

// action creators
const fetchDataRequest = () => ({ type: FETCH_DATA_REQUEST });
const fetchDataSuccess = data => ({ type: FETCH_DATA_SUCCESS, payload: data });
const fetchDataFailure = error => ({ type: FETCH_DATA_FAILURE, payload: error });

// thunk action creator
export const fetchData = () => {
  return function(dispatch) {
    // начинаем запрос данных, dispatch запроса
    dispatch(fetchDataRequest());

    return fetch('https://api.example.com/data')
      .then(response => response.json())
      .then(data => {
        // запрос успешно завершился, dispatch успешного получения данных
        dispatch(fetchDataSuccess(data));
      })
      .catch(error => {
        // запрос завершился с ошибкой, dispatch ошибки
        dispatch(fetchDataFailure(error));
      });
  };
};
```

В этом примере `fetchData` является асинхронным action creator. Функция `fetchData` возвращает новую функцию, которая принимает `dispatch` в качестве аргумента. Это позволяет нам использовать `dispatch` внутри асинхронной операции (в данном случае `fetch`).

Прежде чем начать запрос, мы dispatch `fetchDataRequest()`. Затем, когда данные успешно загружены, мы dispatch `fetchDataSuccess()`, передавая данные в качестве аргумента. Если в процессе возникает ошибка, мы dispatch `fetchDataFailure()`, передавая ошибку в качестве аргумента.

[Оглавление - React 🔼](#menureact)

<div  id="react64"></div>

## 64. `Rtk query/React-query`, Кеширование, инвалидация

**rtk query / react-query**

**React** **Query** - **это** библиотека для получения, кеширования, синхронизации и обновления состояния хранящегося на сервере.

Преимущества:

1. запросы делаются с помощью хуков **useQuery** и **useMutation**, меньше бойлерплейт кода;

2. **Кеширование данных** - при выполнении запросов к серверу библиотека автоматически кэширует полученные данные. Это позволяет избежать повторных запросов на сервер при обращении к тем же данным в разных частях приложения.

3. есть **инвалидация кеша** и запросов, с помощью invalidateQueries и тэгов;

4. есть **оптимистичные обновления** состояний (optimisticUpdates)

5. удобно работать с состоянием загрузки и ошибками, так как хуки возвращают **isLoading**, **error**, то есть не нужно создавать отдельные стейты для ошибок и статуса загрузки;

**Optimistic** **updates** - это концепция, при которой мы сразу обновляем кэшированные данные, или стейт приложения и интерфейс, еще до того, как запрос на сервер будет завершен. Благодаря этому пользователь видит обновления сразу, не дожидаясь ответа от сервера.


**Инвалидация** – актуализация данных запроса, например вызываем мутацию на добавление элемента в список, и нам нужно чтобы query на получение списка перезапросил данные. Обычно это реализуется с помощью ключей (просто строки - [‘todos’, ‘items’]). В react-query чтобы инвалидировать кеш, вызываем:

queryClient`.`invalidateQueries`(“``items``”)`

**useQuery** - используется для выполнения запросов на получение данных (GET)

**useMutation** — для выполнения запросов на изменение данных (например, создание, обновление или удаление, то есть PUT, PATCH, DELETE, POST).

### Как работает кеширование в React Query?

React Query автоматически кеширует данные на основе ключей запросов. Когда запрос выполняется впервые, данные кешируются, и при последующих вызовах с тем же ключом данные берутся из кеша, если они актуальны. Кеширование можно настроить с помощью опций, таких как **staleTime** и **cacheTime**

staleTime — Время, по истечении которого, данные считаются устаревшими. Устаревшие данные перезапрашиваются автоматически при монтировании компонента


Пример использования хуков и реализация инвалидации кеша:

![img](img/20240728095638.png)

[Оглавление - React 🔼](#menureact)

## Разработка и архитектура

<div  id="react66"></div>

## 66. Что такое Компонент высшего порядка (Higher-Order Component, HOC)?

Говоря просто, компонент высшего порядка — это функция, которая принимает компонент и возвращает новый компонент. HOC часто встречаются в сторонних библиотеках, например connect в Redux и createFragmentContainer в Relay.

```js
const EnhancedComponent = higherOrderComponent(WrappedComponent);
```

Давайте реализуем функцию withSubscription — она будет создавать компоненты и подписывать их на обновления DataSource (наподобие CommentList и BlogPost). Функция будет принимать оборачиваемый компонент и через пропсы передавать ему новые данные:

```js
const CommentListWithSubscription = withSubscription(
	CommentList,
	(DataSource) => DataSource.getComments()
);

const BlogPostWithSubscription = withSubscription(
	BlogPost,
	(DataSource, props) => DataSource.getBlogPost(props.id)
);
```

Первый параметр — это оборачиваемый компонент. Второй — функция, которая извлекает нужные нам данные, она получает DataSource и текущие пропсы.

Заметьте, что HOC ничего не меняет и не наследует поведение оборачиваемого компонента, вместо этого HOC оборачивает оригинальный компонент в контейнер посредством композиции. HOC является чистой функцией без побочных эффектов. Вот и всё! Оборачиваемый компонент получает все пропсы, переданные контейнеру, а также проп data. Для HOC не важно, как будут использоваться данные, а оборачиваемому компоненту не важно, откуда они берутся.

[Оглавление - React 🔼](#menureact)

<div  id="react67"></div>

## 67. Что такое строгий режим и зачем он нужен?

Строгий режим (Strict Mode) в React - это вспомогательный компонент, который помогает выявлять потенциальные проблемы в приложении. Он активирует дополнительные проверки и предупреждения для его дочерних компонентов.

Вот некоторые вещи, которые делает строгий режим:

1. **Определение небезопасных методов жизненного цикла**: Некоторые методы жизненного цикла, такие как `componentWillMount`, `componentWillReceiveProps` и `componentWillUpdate`, считаются устаревшими и могут привести к проблемам. Строгий режим поможет определить их использование.

2. **Предупреждение о побочных эффектах**: Строгий режим может предупреждать о побочных эффектах в методах жизненного цикла, вызывая их дважды, чтобы обнаружить нежелательные повторяющиеся эффекты.

3. **Предупреждение о устаревшем использовании строки в `ref`**: Использование строковых значений в `ref` устарело и может привести к проблемам. Строгий режим будет предупреждать об этом.

4. **Предупреждение о неожиданном использовании `findDOMNode`**: Использование `findDOMNode` часто приводит к неоднозначности и лучше его избегать. Строгий режим будет предупреждать об этом.

5. **Определение неэффективного использования контекста**: Если старый API контекста используется в некорректных местах, строгий режим поможет определить это.

Строгий режим не влияет на производительность приложения в продакшн и не приводит к дополнительному рендеру в продакшн-режиме. Он активен только в процессе разработки.

Вот как вы можете использовать его в вашем приложении:

```jsx
import React from 'react';

function App() {
  return (
    <React.StrictMode>
      <div>
        // Ваши компоненты здесь
      </div>
    </React.StrictMode>
  );
}

export default App;
```
В этом примере все дочерние компоненты `<div>` будут проверяться на наличие проблем, выявляемых строгим режимом.

[Оглавление - React 🔼](#menureact)

<div  id="react68"></div>

## 68. Расскажите о `React fiber`?

**Подробнее -** [react fiber](https://ru.reactjs.org/docs/faq-internals.html)

  React Fiber — это переписанная с нуля архитектура React, которая была представлена в React 16. Она была разработана для поддержки некоторых важных функций, таких как:

- **Асинхронная рендеризация**: это позволяет React обрабатывать обновления приоритетов (например, анимации и взаимодействия, которые должны быть более гладкими и реагировать быстрее, чем обновления, производимые в фоновом режиме).

- **Обработка ошибок**: React Fiber вводит границы ошибок (error boundaries), которые позволяют вам обрабатывать ошибки в одной части дерева компонентов без ломки всего приложения.

- **Прерываемость/возобновляемость**: это дает больше контроля над механизмом рендеринга, позволяя React остановить рендеринг, а затем продолжить его позже.

- **Обратная совместимость**: важным аспектом является то, что Fiber полностью обратно совместим с предыдущими версиями.

React Fiber использует концепцию фибр — структур, которые представляют собой единицы работы, которые должны быть выполнены. Это позволяет React управлять процессом рендеринга и делать его более гибким и эффективным.

Важно отметить, что Fiber — это внутренняя реализация React, и большинству разработчиков не нужно знать детали его работы для повседневной разработки. Однако понимание концепций, стоящих за Fiber, может быть полезным для глубокого понимания React и того, как он работает.

[Оглавление - React 🔼](#menureact)

<div  id="react69"></div>

## 69. Расскажите о `React Reconciliation`

**Подробнее -** [Согласование](https://ru.reactjs.org/docs/reconciliation.html%23gatsby-focus-wrapper)

  Процесс согласования (Reconciliation) в React — это алгоритм, который использует React для эффективного обновления DOM. Это процесс, используемый React, чтобы установить, какие части дерева компонентов были изменены и как эти изменения должны быть отражены в DOM.

Основной принцип работы алгоритма согласования включает в себя следующие шаги:

1. **Когда данные в компоненте изменяются (через setState, например), React обновляет этот компонент и его дочерние компоненты.**

2. **React создает новое дерево из компонентов и сравнивает его с предыдущим деревом.**

3. **React затем обновляет DOM, чтобы отразить любые изменения, найденные в процессе сравнения этих двух деревьев.**

Существуют определенные эвристики, которые React использует для ускорения этого процесса:

- Два элемента разных типов порождат разные деревья.
- Разработчик может подсказать React, что элементы могут быть стабильными между разными рендерами с помощью ключа (key prop).

Этот процесс позволяет React быть очень эффективным при обновлении DOM и поддерживать высокую производительность, даже когда рендерятся большие и сложные иерархии компонентов.

[Оглавление - React 🔼](#menureact)

<div  id="react70"></div>

## 70. Что такое `Error boundaries`?

Error boundaries — это способ обрабатывать ошибки в приложении. Это классовый компонент который предоставляют резервный UI интерфейс, если это применимо.

Можно реализовать только на классах т.к в хуках не получится отловить ошибку, нет метода componentDidCatch.

[Оглавление - React 🔼](#menureact)

<div  id="react71"></div>

## 71. `Next.js, CSR, SSR, ISR, SSG` методы getServerSideProps, getStaticPaths, в чем преимущества SSR, когда стоит юзать

React использует CSR, то есть рендер происходит в браузере, сначала идет запрос за пустой HTML страницей, потом загружается JS код. Хуже СЕО и юзер видит контент не сразу.

ISR - позволяет вам поддерживать статически сгенерированные страницы в актуальном состоянии, не требуя полной перестройки вашего приложения и не влияя на время отклика. Next.js позволяет указать время повторной валидации для каждой страницы с помощью revalidate: 60

Cуществует 3 функции для получения данных, необходимых для предварительного рендеринга:
• getStaticProps (SSG): это функция для получения данных, необходимых для предварительного рендеринга, из файла должна экспортироваться асинхронная. Данная функция вызывается во время сборки и позволяет передавать полученные данные странице в виде props. Запускается только на сервере, поэтому ее нельзя использовать для обращения к внутренним роутам.
• getServerSideProps (SSR): получение данных при каждом запросе, данные обновляются каждый раз, когда пользователь загружает страницу. Предварительно генерирует HTML на сервере при каждом запросе. следует использовать при необходимости предварительного рендеринга страницы на основе данных, зависящих от запроса.
• getStaticPaths (SSG): определение динамических роутов для предварительного рендеринга страниц на основе данных. Страницы с динамической маршрутизацией, из которых экспортируется асинхронная функция getStaticPaths, будут предварительно сгенерированы для всех путей, возвращаемых этой функцией.

SSR - это процесс, при котором сервер генерирует HTML и отправляет его клиенту. Каждый раз, когда пользователь запрашивает страницу, сервер генерирует ее заново. SSR обычно используется для динамических сайтов, где содержимое страницы зависит от пользовательских действий или данных, хранящихся на сервере. Плюсы - для улучшения SEO оптимизации, лучше индексируется поисковыми системами, для более быстрой загрузки. Минусы - Увеличение нагрузки на сервер; Более сложен в разработке и тестировании, необходимо синхронизировать состояние между сервером и клиентом, использовать специфические, надо учитывать что в некоторых случаях нет доступа к браузерному API, window, document

SSG - это процесс, при котором сайт генерируется на стороне сервера и сохраняется в виде статических файлов. Каждый раз, когда пользователь запрашивает страницу, сервер просто отправляет готовый HTML-код. Предусматривает генерацию HTML во время сборки и его повторное использование при каждом запросе. SSG обычно используется для статических сайтов, где содержимое страницы не зависит от пользовательских действий или данных, хранящихся на сервере. SSG быстрее чем SSR.


С серверными компонентами начальная загрузка страницы происходит быстрее, и размер пакета JavaScript на стороне клиента уменьшается. Html страница рендерится на сервере.
- нельзя юзать хуки, браузереное API
- нельзя использовать серверные компоненты внутри клиентских
+ ускорение загрузки страницы
+ использовать для получения данных с серва

Клиентские компоненты выполняются на клиенте и позволяют вам добавлять интерактивность на стороне клиента в ваше приложение, использовать хуки и тд.

[Оглавление - React 🔼](#menureact)

## Разное

<div  id="react72"></div>

## 72. Чем `React Native` отличается от `ReactJS`?

React (или ReactJS) и React Native являются популярными JavaScript-библиотеками, разработанными Facebook. Они обе основаны на концепции компонентов и используют Virtual DOM для оптимизации рендеринга, но предназначены для разных целей.

1. **ReactJS** предназначен для построения интерфейсов веб-приложений. Он позволяет разработчикам создавать масштабируемые и быстро реагирующие веб-приложения с использованием JavaScript и концепции компонентов.

2. **React Native** предназначен для разработки нативных мобильных приложений. React Native позволяет разработчикам писать код на JavaScript, который затем компилируется в нативный код для каждой платформы (iOS или Android). Это позволяет создавать высокопроизводительные мобильные приложения, которые выглядят и ведут себя как нативные приложения, но при этом разрабатываются на JavaScript.

Основное различие между ReactJS и React Native заключается в том, что ReactJS используется для веб-разработки, в то время как React Native используется для разработки мобильных приложений. Это включает в себя различия в API для работы с DOM и устройствами, специфичными для каждой платформы, такими как камера или геолокация.

Тем не менее, навыки, приобретенные при изучении одной из этих библиотек, в большой степени применимы к другой, что делает переход от веб-разработки к мобильной (или наоборот) довольно простым для разработчиков React.

[Оглавление - React 🔼](#menureact)

<div  id="react73"></div>

## 73. Как вы отлаживаете приложения React и какие инструменты можете использовать?

Отладка приложений React - важная часть процесса разработки. Есть несколько инструментов и методов, которые можно использовать:

1. **React Developer Tools**: Это расширение для браузера, которое можно установить в Google Chrome, Firefox и других. Оно позволяет вам исследовать дерево компонентов React, их свойства, состояние и так далее.

2. **Консоль браузера**: Вы можете использовать `console.log`, `console.error` или `console.warn` для вывода информации прямо в консоль браузера. Ошибки компиляции и исключения также появляются здесь.

3. **Отладчик JavaScript в браузере**: Большинство современных браузеров имеют встроенные инструменты разработчика с отладчиком JavaScript, который позволяет ставить точки останова, шагать через код и т.д.

4. **Инструменты тестирования**: Инструменты, такие как Jest, могут быть использованы для написания юнит-тестов, которые помогут проверить, работает ли ваш код так, как ожидается.

5. **React Profiler**: Это часть расширения React Developer Tools и может быть использована для измерения производительности вашего React приложения. Он поможет вам выявить медленные компоненты, которые требуют оптимизации.

6. **Redux Developer Tools**: Если вы используете Redux, инструменты разработчика Redux позволят вам исследовать текущее состояние хранилища, предыдущее состояние, следующее состояние и т.д.

Все эти инструменты могут быть полезными для отладки вашего приложения React и помогут вам понять, что происходит в вашем приложении в любой момент времени.

[Оглавление - React 🔼](#menureact)

<div  id="react74"></div>

## 74. Когда вам стоит использовать Class Component вместо Functional Component?

С введением Hooks в React 16.8, функциональные компоненты могут делать практически всё то же самое, что и классовые компоненты. Тем не менее, есть несколько ситуаций, когда вы можете предпочесть использовать классовые компоненты:

1. **Обработка ошибок с помощью Error Boundaries**: На текущий момент, Error Boundaries могут быть только классовыми компонентами. Это позволяет обрабатывать ошибки в любом дочернем компоненте с помощью lifecycle метода `componentDidCatch`.

2. **Нужен метод `componentDidMount`**: Если вам нужно выполнять действия прямо после того, как компонент был вставлен в DOM, вы можете использовать `componentDidMount` в классовом компоненте. Хотя эффекты (`useEffect`) в функциональных компонентах предоставляют аналогичную функциональность, некоторые разработчики находят классовый подход более ясным и удобным.

3. **Использование сторонних библиотек**: Некоторые библиотеки требуют использования методов жизненного цикла класса, или еще не полностью совместимы с Hooks.

4. **Большие и сложные компоненты**: Для очень больших и сложных компонентов классы могут быть более читаемыми и удобными для отладки. Кроме того, некоторые разработчики считают, что управление большим количеством состояний и эффектов с помощью hooks может стать запутанным.

Несмотря на это, новые проекты на React часто используют функциональные компоненты и Hooks, поскольку они могут быть более лаконичными и гибкими. Классовые компоненты, однако, все еще важны для понимания, особенно если вы работаете с существующим кодом, который еще не переведен на функциональные компоненты и Hooks.

[Оглавление - React 🔼](#menureact)

<div  id="react75"></div>

## 75. Почему ушли от классов к функциям в реакте

Почему ушли от классов к функциям:
1 – функции более читабельные и легче для понимания,
2 – не нужно беспокоиться об this, биндить методы,
3 – не нужно использовать методы по типу constructor, render,
4 – в функциях можно юзать хуки, а в классах – методы жизненного цикла,
5 – в функциональных функции пересоздаются при каждом рендере, в классах - нет

[Оглавление - React 🔼](#menureact)

<div  id="react76"></div>

## 76. В каких случаях можно использовать локальное состояние, а в каких лучше использовать глобальный State?

Локальное состояние рекомендуется использовать в тех случаях, когда оно используется только в рамках 1го компонента и не планируется передавать его в других компоненты.

Также локальное состояние используется в компоненте какого-то отдельного элемента списка.

Если же декомпозиция на компоненты предполагает вложенность с передачей данных по иерархии, то лучше использовать global state.

[Оглавление - React 🔼](#menureact)

<div  id="react77"></div>

## 77. Декларативность и императивность

Декларативный – то есть мы не предоставляем пошаговых инструкций для достижения желаемого интерфейса. А просто описываем конечный интерфейс, который мы хотим получить, через JSX.

В императивном подходе сначала опишем кнопку на HTML, а затем добавим отдельные стили и функции на чистом JavaScript

[Оглавление - React 🔼](#menureact)
