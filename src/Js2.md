<div align="center"><h1><img src="https://img.shields.io/badge/javascript-%23323330.svg?style=for-the-badge&logo=javascript&logoColor=%23F7DF1E" alt="js" width="300" height="70"></h1></div>

[⚙️ Back to menu](../README.md)

<div id="menu"></div>

| No.|             Вопрос                   |
|:---|:-------------------------------------|
|  | <h3>Основы JavaScript</h3> |
|1| [Какие типы данных существуют в JavaScript и почему у примитивов есть методы](#1)|
|2| [Какие значения являются falsy(ложными) значениями? **(false, 0, "", undefined, null, NaN)**](#9)|
|3| [Что такое подъем или hoisting?](#3)|
|4| [Что такое замыкание??](#6)|
|5| [Что такое «strict» mode в JS?](#4)|
|6| [В чем разница между операторами `==` и `===`?](#5)|
|7| [В чем разница между null и undefined?](#6)|
|8| [Что такое тернарный оператор? `(true ? 'yes' : 'no')`](#7)|
|9| [Что такое **new Set()** и **new Map()**?](#8)|
|10| [Почему typeof массива === object](#10)|
|11| [Для чего нужен оператор `[...spread]`?](#11)|
|12| [Остаточные параметры и оператор расширения (rest)](#37)|
|13| [Что такое Promise? **({}, Pending, Fulfilled, Rejected)**](#12)|
|14| [методы экземпляра Promise и статические методы Promise](#13)|
|15| [Что такое `async/await`?](#14)|
|16| [Какие способы работы с асинхронным кодом вы знаете? `(Callbacks, Promises, Async/Await)`](#15)|
|17| [Микро и макро таски в JavaScript](#36)|
|18| [Зачем нужны промисы, если можно работать с асинхронным кодом с помощью функций обратного вызова (callbacks)?](#51)|
|19| [Что такое `Event loop` (цикл событий)?](#16)|
|20| [Как работает ключевое слово  `this`?](#16)|
|21| [Как поменять контекст функции? `call`, `bind`, `apply`](#16)|
|22| [Что такое шаблонные литералы и для чего они нужные?](#17)|
|23| [Optional chaining оператор. Для чего нужен?](#50)|
|24| [Операторы логического присваивания](#80)|
|  | <h3>Переменные и функции</h3> |
|25| [Отличия **var**, **let** и **const**?](#18)|
|26| [Что такое функция первого класса?](#19)|
|27| [Стрелочные функции и их отличие от функций, объявленных через function](#20)|
|28| [function expression и function declaration. Что это такое и в чем разница?](#21)|
|29| [Что такое анонимная функция?](#22)|
|30| [Что такое IIFE (Самовызывающиеся функции)?](#23)|
|31| [Что такое - функция конструктор?](#23)|
|32| [Что такое чистая функция?](#24)|
|33| [Что такое функция высшего порядка?](#25)|
|34| [Что такое каррирование (функция карри)?](#26)|
|35| [Как отслеживать и обрабатывать ошибки в JavaScript? `Try/Catch/Finally`](#27)|
|36| [Что такое рекурсия? Как предотвратить бесконечную рекурсию?](#28)|
|37| [Что такое генераторы в JavaScript и как они работают?](#37)|
|  | <h3>Объекты и прототипы:</h3> |
|38| [Что такое прототипное наследование?](#29)|
|39| [Что такое прототип объекта в JavaScript? `Prototype`](#30)|
|40| [Какие способы создания объекта вы знаете?](#31)|
|41| [Как избежать ссылочной зависимости при копировании объекта? Поверхстное и Глубокое копирование объекта](#16)|
|42| [Методы статического объекта](#79)|
|43| [Как сделать объект неизменяемым, методы `Object.freeze`, `Object.seal`, `Object.defineProperty`](#32)|
|44| [Что такое деструктуризация?](#33)|
|45| [Как определить наличие свойства в объекте? **hasOwnProperty**](#34)|
|46| [Как получить свойство объекта? `Object.keys, Object.values, Object.entries`](#35)|
|47| [Дескрипторы свойств объекта](#36)|
|48| [Что такое объект `Proxy`](#37)|
|49| [Как работает ключевое слово new?](#38)|
|50| [Как сделать наследование класса в ES6?](#39)|
|51| [Конструкторы, constructor](#40)|
|52| [Как проверить, из какого класса был создан объект? `instanceof`](#41)|
|53| [Что такое статический метод класса (static)?](#42)|
|54| [Почему два объекта с одинаковыми полями при сравнении дают false?](#43)|
|55| [Как удалить ключ у объекта?](#45)|
|56| [Как проверить, является ли объект массивом? `Array.isArray(arr)`](#53)|
|57| [Что такое дескрипторы свойств?](#77)|
|58| [Ключевое слово `super`](#65)|
|  | <h3>DOM и работа с событиями:</h3> |
|59| [Что такое DOM дерево?](#47)|
|60| [Что такое Shadow DOM?](#30)|
|61| [Распространение события и фазы](#47)|
|62| [Всплытие и погружение событий. `bubbling, capturing`](#48)|
|63| [`e.preventDefault()` и `e.stopPropagation()`, `e.stopImmediatePropagation` для чего нужны?](#47)|
|64| [Что такое делегирование событий в JS?](#44)|
|65| [Отличие Event.target от event.currentTarget](#49)|
|66| [Что такое throttle и debounce?](#51)|
|  | <h3>Асинхронность и запросы:</h3> |
|67| [Как остановить интервал? `clearInterval(intervalId)`](#52)|
|68| [Что такое `requestAnimationFrame`?](#53)|
|69| [Что такое `requestIdleCallback`?](#54)|
|70| [функция `fetch()`](#55)|
|71| [`AbortController()`](#56)|
|72| [Какие есть способы для работы с запросами в React?](#57)|
|73| [Как сервер может запретить чтение cookie из браузера? **(флаг HttpOnly)**](#58)|
|  | <h3>Массивы и строки:</h3> |
|74| [Методы массивов в JavaScript](#59)|
|75| [Методы строк в JavaScript](#60)|
|76| [Как проверить, является ли объект массивом?](#61)|
|  | <h3>Локальное хранение данных:</h3> |
|77| [Какие способы хранения данных в браузере вы знаете? **(LocalStorage, sessionStorage, Cookies, IndexedDB)**](#38)|
|78| [В чем отличие sessionStorage от localStorage?](#39)|
|  | <h3>Разное:</h3> |
|79| [Что будет, если добавить скрипт перед тегом body?](#52)|
|80| [Разница между `<script>`, `<script async>` и `<script defer>`](#88)|
|81| [Преимущества javascript](#63)|
|82| [Что такое типизированный язык?](#2)|
|83| [WeakSet и WeakMap: отличие от Map и Set](#43)|
|84| [Сборщик мусора](#96)|
|85| [Shadow DOM](#30)|
|86| [Что такое регулярные выражения?](#42)|
|87| [Зачем нужны полифилы?](#32)|
|88| [Что такое `Service worker`?](#92)|
|89| [Что такое `Web Worker`?](#93)|
|90| [Что такое ECMAScript?](#71)|
|91| [Что такое ES Модуль?](#94)|
|92| [Что такое катаморфизмы?](#64)|
|93| [Что такое анаморфизмы?](#63)|
|94| [Что такое Compose?](#90)|
|95| [Различия между старым JS и новым JS](#67)|
|96| [Структуры данных](#84)|
|97| [Как дебажить приложение и причины утечек памяти?](#104)|
|98| [В чем разница между host и native объектами?](#61)|
|99| [Mutable vs Immutable в JS](#57)|
|100| [Как ты будешь дебажить приложение, из-за чего бывают утечки памяти?](#104)|
|101| [Какие особенности есть у JavaScript?](#95)|
|102| [`Intl` - интернационализация в JavaScript](#102)|
|103| [Что такое Event.target и event.currentTarget](#75)|
|104| [Что такое мемоизация и кеширование?](#17)|


---

## Основы JavaScript

<div id="1"></div>

## 1. Какие типы данных существуют в JavaScript и почему у примитивов есть методы

### Типы данных

1. **Number** - числа, Единый тип число используется как для целых, так и для дробных чисел. К **Number** относится **Infinity** (бесконечность) и **NaN** (ошибка вычислений).
2. **String** - строки `"text"`
3. **Boolean** - тип Булевый (логический) `True/False`
4. **Object** – «объект» Он используется для коллекций данных и для объявления более сложных сущностей.  `{...}`
5. **null** - специальное значение, которое представляет собой «ничего», «пусто» или «значение неизвестно».
6. **undefined** - означает, что «значение не было присвоено». Если переменная объявлена, но ей не присвоено никакого значения, то её значением будет undefined.
7. **Symbol** - это уникальный и неизменяемый тип данных, который может быть использован как идентификатор для свойств объектов.
8. **BigInt** - используется для создания больших чисел. `const bigInt = 1234567890101234567890n; `

### Примитивы

**Примитивные типы данных** в JavaScript - это базовые типы данных, которые не могут быть изменены или манипулированы дальше. Они включают следующие типы:

1. **Number**
2. **String**
3. **Boolean**
4. **Null**
5. **Undefined**
6. **Symbol** (ES6)
7. **BigInt** (в некоторых новых версиях JavaScript)

Особенностью примитивных типов данных является то, что они передаются по значению, а не по ссылке. Это означает, что когда вы присваиваете примитивное значение переменной и затем присваиваете это значение другой переменной, изменения в одной переменной не повлияют на другую.

**Не примитивные типы данных** в JavaScript - это объекты и функции, которые могут содержать другие значения и иметь уникальные свойства и методы. Не примитивные типы данных включают в себя:

1. **Object**
2. **Array []** (специальный тип объекта для хранения упорядоченных коллекций)
3. **Function** (специальный тип объекта для хранения исполняемого кода)

Не примитивные типы данных в JavaScript передаются по ссылке, что означает, что если вы присваиваете объект или функцию переменной и затем присваиваете это значение другой переменной, изменения в одной переменной будут отражаться и в другой.

### Почему у примитивов (number,string …) мы можем вызывать методы? Например ‘some string’.toLowerCase()?

**Подробнее –** [методы примитивов](https://learn.javascript.ru/primitives-methods)

Каждый примитив имеет собственный объект-обёртку, которые называются: String, Number, Boolean, Symbol и BigInt.

А прототипы этих обьектов уже имеют разный набор методов.

И вот когда происходит обращение к какому-то методу у примитива, он автоматически оборачивается в обьект-обертку, этот механизм называется Autoboxing

К примеру, существует метод str.toUpperCase(), который возвращает строку в верхнем регистре.

[Оглавление - JavaScript 🔼](#menu)

<div id="2"></div>

## 2. Что такое типизированный язык?

Типизированный язык программирования - это язык, в котором каждая переменная, каждое выражение имеет определенный тип, который определяет операции, которые могут быть выполнены с этими данными, их значением и т.д.

В типизированных языках программирования типы данных переменных обычно определяются во время компиляции, что позволяет обнаружить и предотвратить многие виды ошибок еще до выполнения программы.

Типизация может быть:

1.  **Статическая**: В статически типизированных языках, таких как C++, Java, Rust, и TypeScript, типы данных переменных известны на этапе компиляции. Тип каждой переменной должен быть определен в момент объявления, и его уже нельзя изменить.
2.  **Динамическая**: В динамически типизированных языках, таких как JavaScript, Python, и Ruby, тип переменной может быть изменен в процессе выполнения программы, и типы данных переменных определяются во время выполнения.


Кроме того, типизация может быть:

1.  **Явная**: При явной типизации программист должен указать тип переменной при ее объявлении. Например, в языке C++ вы бы написали `int x = 10;` чтобы объявить целочисленную переменную `x`.
2.  **Неявная**: При неявной типизации компилятор или интерпретатор самостоятельно определяет тип переменной на основе присвоенного ей значения. Например, в JavaScript вы можете просто написать `var x = 10;` и интерпретатор сам поймет, что `x` - это число.


Также есть понятия сильной и слабой типизации, которые относятся к тому, насколько строго язык соблюдает и контролирует правила своей системы типов

[Оглавление - JavaScript 🔼](#menu)

<div id="3"></div>

## 3. Что такое подъем или hoisting?

По умолчанию в JavaScript все объявления перемещаются в верхнюю часть текущей области видимости (в верхнюю часть текущего скрипта или текущей функции). JavaScript поднимает только объявления, но не инициализации.

[Оглавление - JavaScript 🔼](#menu)

<div id="4"></div>

## 4. Что такое «strict» mode в JS?

Строгий режим (strict mode) обеспечивает более тщательную проверку ошибок в коде и упрощает отладку.

Чтобы включить строгий режим, нужно добавить **`use strict`** в начале файла.

пример:
```js
'use strict';
x = 3.14; // Ошибка, переменная не объявлена
```

А так же, если вы попытаетесь обратиться к ключевому слову this в глобальной области видимости, при включенном strict-mode оно будет === undefined,
в обычном режиме: window - в браузере, {} - в ноде.

[Оглавление - JavaScript 🔼](#menu)

<div id="5"></div>

## 5. В чем разница между операторами `==` и `===`?

**Подробнее** - [Операторы сравнения](https://learn.javascript.ru/comparison)
- Оператор '==' проверяет равенства с приведением типов. Это означает, что перед сравнением операндов, JavaScript попытается привести их к общему типу. Если операнды разных типов, JavaScript попытается преобразовать один из них, чтобы они совпадали.

- Оператор '===' проверяет на строгое равенство, т.е. он не будет выполнять преобразование типа, поэтому, если два значения не одного типа, при сравнении он вернет false.

[Оглавление - JavaScript 🔼](#menu)

<div id="6"></div>

## 6. В чем разница между null и undefined?

***Подробнее*** - [Null и Undefined](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/null)

Оба варианта означают пустое значение. Если мы инициализируем переменную, но не присваиваем ей значение, туда помещается специальный «маркер», который отображается при выводе на экран как undefined. **Null** присваиваем самостоятельно.

**Null** - Это просто специальное значение, которое представляет собой «ничего», «пусто» или «значение неизвестно». Если необходимо очистить значение переменной, мы делаем q = null.

**undefined** означает, что «значение не было присвоено».

[Оглавление - JavaScript 🔼](#menu)

<div id="7"></div>

## 7. Что такое тернарный оператор? `(true ? 'yes' : 'no')`

**Подробнее -** [тернарный оператор](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/Conditional_Operator)

Это аналогичная запись if else. Тернарный оператор в JavaScript — это удобный синтаксис для выполнения простого условного выражения. Он называется "тернарный", потому что включает в себя три операнда.

Структура тернарного оператора следующая: `условие ? выражение1 : выражение2`

-   `условие` — это выражение, которое оценивается как `true` или `false`.
-   `выражение1` выполняется, если `условие` истинно (т.е. оценивается как `true`).
-   `выражение2` выполняется, если `условие` ложно (т.е. оценивается как `false`).

Например, предположим, что у вас есть переменная `isTrue`, и вы хотите присвоить переменной `message` значение `"Hello, world!"`, если `isTrue` истинно, и `"Goodbye, world!"`, если `isTrue` ложно. Вы можете сделать это с помощью тернарного оператора следующим образом:

```js
let isTrue = true;
let message = isTrue ? "Hello, world!" : "Goodbye, world!";
```
Тернарный оператор обычно используется для простых условных выражений и может сделать ваш код более кратким и читаемым. Однако для сложных условий или многострочных выражений лучше использовать стандартную конструкцию `if` / `else`.

[Оглавление - JavaScript 🔼](#menu)

<div id="8"></div>

## 8. Что такое set и map?

**Подробнее -** [Set и Map](https://learn.javascript.ru/map-set)

**Set** - это коллекция уникальных элементов. Элементы могут быть любого типа. Своего рода массив, но в отличие от массива, Set не поддерживает доступ по индексу, но можно добавлять элементы, удалять их и проверять наличие элемента в коллекции.

**Set** имеют методы **set.add()**, **set.delete()**, **set.has()**, **set.values()** и тд

```js
let mySet = new Set();
mySet.add(1); // Добавляет элемент в Set
mySet.add(2);
mySet.add(3);
mySet.add(2); // Не будет добавлено, так как значение 2 уже присутствует в Set
console.log(mySet.has(1)); // true
console.log(mySet.size); // 3
```
**Map** - это коллекция пар "ключ-значение", где ключи уникальны. В отличие от обычных объектов JavaScript, ключами в Map могут быть значения любого типа, включая объекты. Map поддерживает добавление, удаление и поиск пар "ключ-значение".

**Map** имеет методы для получения ключей и значений **Map.keys()**, **Map.values()**, **Map.entries()**, **Map.has()**

```js
let myMap = new Map();
myMap.set('name', 'Alice'); // Добавляет пару "ключ-значение" в Map
myMap.set('age', 25);
console.log(myMap.get('name')); // 'Alice'
console.log(myMap.has('age')); // true
console.log(myMap.size); // 2
```
---
Оба типа коллекций поддерживают итерацию, так что вы можете пройтись по всем элементам Set или Map с помощью цикла `for...of` или метода `forEach`.

[Оглавление - JavaScript 🔼](#menu)

<div id="9"></div>

## 9. Какие значения являются falsy (ложными) значениями?

**Подробнее -** [falsy значения](https://webformyself.com/kak-na-samom-dele-v-javascript-rabotayut-operatory-i/)

Falsy значение – значение, которое при приведении к логическому типу возвращает false.

```js
console.log (false) // само логическое значение `false`.
console.log (!!0) // число ноль.
console.log (!!"") // пустая строка.
console.log (!!undefined) // специальное значение, указывающее на то, что переменная не была инициализирована.
console.log (!!null) // специальное значение, обозначающее "ничего" или "отсутствие значения".
console.log (!!NaN) // специальное значение, обозначающее "не число" ("Not a Number").
```
Все остальные значения в JavaScript, включая все объекты (и массивы), считаются "truthy", то есть они преобразуются в `true`, когда их приводят к логическому типу.

[Оглавление - JavaScript 🔼](#menu)

<div id="10"></div>

## 10. Почему typeof массива === object

**Array** относится к **object**, так как он создается с помощью конструктора класса **new Array()** и является его экземпляром, а значением свойства **_proto_** в **Array.prototype** является **Object.prototype**

Это означает, что массивы – наследуются от обьектов

[Оглавление - JavaScript 🔼](#menu)

<div id="11"></div>

## 11. Для чего нужен оператор `[...spread]`?

**Подробнее -** [Spread](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/Spread_syntax)

Оператор расширения (spread operator) `...` в JavaScript используется для распаковки(разворачивания) элементов из итерируемых объектов, таких как массивы или объекты.

1.  **В массивах**: Spread оператор может быть использован для копирования или объединения массивов.
```js
let arr1 = [1, 2, 3];
let arr2 = [...arr1, 4, 5, 6];  // arr2 теперь равен [1, 2, 3, 4, 5, 6]
```
2.  **В объектах**: Spread оператор может быть использован для копирования или объединения свойств объектов.
```js
let obj1 = { a: 1, b: 2 };
let obj2 = { ...obj1, c: 3 };  // obj2 теперь равен { a: 1, b: 2, c: 3 }
```
3.  **В аргументах функции**: Spread оператор может быть использован для передачи элементов массива как отдельных аргументов функции.
```js
let arr = [1, 2, 3];
console.log(Math.max(...arr));  // Выведет 3
```
4.  **Для преобразования итерируемых объектов в массивы**:
```js
let str = "Hello";
let chars = [...str];  // chars теперь равен ['H', 'e', 'l', 'l', 'o']
```

Spread оператор является мощным инструментом, который позволяет более легко манипулировать данными и делает ваш код более читаемым и коротким.

[Оглавление - JavaScript 🔼](#menu)

<div id="12"></div>

## 12. Что такое Promise?

**Подробнее -** [Promise](https://learn.javascript.ru/promise-basics)

**Promise** – это специальный объект, предназначенный для работы с ассинхронным кодом и который содержит своё состояние.

Promise может находиться в одном из трех состояний:

1.  **Ожидание (Pending)**: Начальное состояние Promise, не выполнен и не отклонен.
2.  **Выполнен (Fulfilled)**: Значит, операция завершилась успешно.
3.  **Отклонен (Rejected)**: Операция завершилась с ошибкой.

Promise используется со следующим синтаксисом:
```js
let promise = new Promise((resolve, reject) => {
  // асинхронная операция
  if (/* всё прошло успешно */) {
    resolve('Результат');
  }
  else {
    reject('Ошибка');
  }
});

promise.then(
  result => {
    /* обработать успешное выполнение */
  },
  error => {
    /* обработать ошибку */
  }
);
```
Метод `then` принимает две функции: первая вызывается, когда Promise переходит в состояние "fulfilled", и она получает результат. Вторая вызывается, когда Promise переходит в состояние "rejected", и она получает ошибку.

Есть и другие методы, такие как `catch` (для обработки ошибок) и `finally` (для выполнения кода после завершения Promise, независимо от его результата).

Промисы могут быть соединены в цепочки для выполнения последовательности асинхронных операций.

Способ использования, в общих чертах, такой:

1. Код, которому надо сделать что-то асинхронно, создаёт объект promise и возвращает его.
2. Внешний код, получив promise, навешивает на него обработчики.
3. По завершении процесса асинхронный код переводит promise в состояние fulfilled (с результатом) или rejected (с ошибкой). При этом автоматически вызываются соответствующие обработчики во внешнем коде.

[Оглавление - JavaScript 🔼](#menu)

<div id="13"></div>

## 13. методы экземпляра Promise и статические методы Promise

В JavaScript промисы (Promises) представляют собой объект, который используется для асинхронных операций. Они предоставляют методы для работы с результатами этих операций. Основные методы промисов включают:

### Методы экземпляра промиса

Эти методы доступны на конкретных экземплярах промисов.

1. **`then(onFulfilled, onRejected)`**
   - Используется для обработки успешного завершения промиса (`onFulfilled`) или его отклонения (`onRejected`). Оба аргумента являются необязательными.
   - Возвращает новый промис, который разрешается или отклоняется в зависимости от возвращаемого значения обработчиков.

   ```javascript
   promise.then(result => {
     console.log(result);
   }, error => {
     console.log(error);
   });
   ```

2. **`catch(onRejected)`**
   - Обработчик, который вызывается, если промис был отклонен. Фактически это эквивалент `then(null, onRejected)`.
   - Возвращает новый промис, позволяя выстраивать цепочки.

   ```javascript
   promise.catch(error => {
     console.error(error);
   });
   ```

3. **`finally(onFinally)`**
   - Метод, который вызывается независимо от того, был ли промис разрешен или отклонен.
   - Возвращает новый промис, который разрешается или отклоняется на основе исходного промиса.

   ```javascript
   promise.finally(() => {
     console.log('Промис завершён');
   });
   ```

### Статические методы промиса

Эти методы вызываются на конструкторе `Promise`, а не на его экземплярах.

1. **`Promise.resolve(value)`**
   - Возвращает промис, который будет разрешён с указанным значением.
   - Если значение уже является промисом, возвращает его.

   ```javascript
   let resolvedPromise = Promise.resolve('Успех');
   resolvedPromise.then(value => {
     console.log(value); // 'Успех'
   });
   ```

2. **`Promise.reject(reason)`**
   - Возвращает промис, который будет отклонён с указанной причиной.

   ```javascript
   let rejectedPromise = Promise.reject('Ошибка');
   rejectedPromise.catch(error => {
     console.error(error); // 'Ошибка'
   });
   ```

3. **`Promise.all(iterable)`**
   - Принимает итерацию (обычно массив) промисов и возвращает промис, который разрешается, когда все промисы в итерации разрешены, или отклоняется, если один из промисов был отклонён.
   - Если все промисы разрешены, возвращает массив их результатов.

   ```javascript
   Promise.all([promise1, promise2]).then(values => {
     console.log(values);
   }).catch(error => {
     console.error(error);
   });
   ```

4. **`Promise.race(iterable)`**
   - Возвращает промис, который разрешается или отклоняется с результатом первого завершившегося промиса в итерации.

   ```javascript
   Promise.race([promise1, promise2]).then(value => {
     console.log(value);
   }).catch(error => {
     console.error(error);
   });
   ```

5. **`Promise.allSettled(iterable)`**
   - Возвращает промис, который разрешается, когда все переданные промисы завершены, независимо от того, были ли они разрешены или отклонены. Возвращает массив объектов, каждый из которых содержит статус (`fulfilled` или `rejected`) и значение или причину.

   ```javascript
   Promise.allSettled([promise1, promise2]).then(results => {
     results.forEach(result => {
       console.log(result.status);
     });
   });
   ```

6. **`Promise.any(iterable)`**
   - Возвращает промис, который разрешается, как только один из переданных промисов будет разрешён. Если все промисы отклонены, возвращает промис, который отклоняется с массивом причин отклонения.

   ```javascript
   Promise.any([promise1, promise2]).then(value => {
     console.log(value);
   }).catch(error => {
     console.error('Все промисы были отклонены:', error);
   });
   ```

[Оглавление - JavaScript 🔼](#menu)

<div id="14"></div>

## 14. Что такое `async/await`?

**Подробнее -** [async/await](https://learn.javascript.ru/async-await)

`async` и `await` - это специальные ключевые слова в JavaScript, которые позволяют работать с промисами (Promise) более удобным и читаемым способом.

-   `async` указывается перед объявлением функции и гарантирует, что функция всегда возвращает промис.

-   `await` используется для приостановки выполнения асинхронной функции и ожидания завершения промиса, а затем возвращает результат промиса. `await` может быть использован только внутри `async` функции.

Допустим, у вас есть функция, которая возвращает промис, например, функция `fetch`, которая делает HTTP-запрос:
```js
async function fetchData(url) {
  try {
    let response = await fetch(url);

    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }

    let data = await response.json();

    console.log(data);
  } catch (error) {
    console.log('Error:', error);
  }
}

fetchData('https://api.example.com/data');
```
В этом примере функция `fetchData` объявлена как `async`, поэтому она может использовать `await` для ожидания завершения промиса, возвращаемого функцией `fetch`. Когда промис завершается, его результат сохраняется в переменной `response`.

Если `fetch` успешно завершается, выполняется `response.json()`, который также возвращает промис, и снова используется `await` для ожидания его завершения.

Если в любой момент происходит ошибка (например, сетевая ошибка или ошибка статуса HTTP), она будет перехвачена блоком `catch`.

Использование `async` и `await` может сделать ваш код более чистым и понятным, особенно при работе с большим количеством промисов или сложными цепочками промисов.

[Оглавление - JavaScript 🔼](#menu)

<div id="15"></div>

## 15. Какие способы работы с асинхронным кодом вы знаете?

**Подробнее -** [Асинхронный JavaScript](https://developer.mozilla.org/ru/docs/Learn/JavaScript/Asynchronous/Introducing)

Существуют 3 способа обработки асинхронных событий:

1.  **Обратные вызовы (Callbacks)**: Это функции, которые вызываются, когда асинхронная операция завершена. Обратные вызовы были одним из первых способов работы с асинхронностью в JavaScript.
```js
fs.readFile('file.txt', 'utf-8', function(err, data) {
  if (err) {
    console.error('Error:', err);
  } else {
    console.log(data);
  }
});
```
2.  **Промисы (Promises)**: Промисы - это объекты, которые представляют итог асинхронной операции. Промисы облегчают работу с асинхронными операциями, предоставляя стандартный интерфейс для их обработки.
```js
fetch('https://api.example.com/data')
  .then(response => response.json())
  .then(data => console.log(data))
  .catch(error => console.error('Error:', error));
```
3.  **Async/Await**: Это синтаксический сахар для промисов, который позволяет писать асинхронный код, который выглядит и ведет себя как синхронный.
```js
async function fetchData() {
  try {
    let response = await fetch('https://api.example.com/data');
    let data = await response.json();
    console.log(data);
  } catch (error) {
    console.error('Error:', error);
  }
}

fetchData();
```

[Оглавление - JavaScript 🔼](#menu)

<div id="16"></div>

## 16. Что такое `Event loop` (цикл событий)?

**Подробнее -** [Наглядный пример](https://www.youtube.com/watch?v=377qAu37OTE&ab_channel=UlbiTV)

**Подробнее -** [Event loop](https://learn.javascript.ru/event-loop)

---

**Event loop** – Это бесконечный цикл, в котором выполняются обработчики событий.

Браузер распределяет эти обработчики по очередям (микротаски и макротаски).

Асинхронный код выполняется в фоне и не блокирует основной поток.

Макротаска это например – **setTimeout**, **евенты**, **таймеры**, **fetch**;

Микрозадачи – **промисы**, **queMicrotask()**, **mutationObserver**.

Все микрозадачи в очереди будут выполнены только после того, как текущий стек вызовов окажется пустым (и выполнится синхронный код), но перед выполнением следующей макрозадачи.

Если МАКРО пораждает МИКРО, то выполнится МАКРО а после нее все МИКРО. Микро блочат луп, а макро нет.

**JS** является однопоточным и **eventloop** позволяет браузеру обрабатывать асинхронные операции, не блокируя основной поток выполнения.

Порядок выполнения кода:
- Сначала выполняются все синхронные задачи
- Потом выполняются все задачи из микротасков
- После выполнения всех микротасков - очередь очищается
- Затем мы берем одну макрозадачу из списка и выполняем ее
- После выполнения мы смотрим нужно ли нам сделать перерисовку страницы
- Если перерисовать страницу нужно - делаем это

**Call stack (LIFO)** – стэк вызова функций, вызывается 1 функция, если внутри нее есть вызов еще одной функции, то она добавляется в стэк, после выполнения функции она убирается из стэка.

Асинхронный код попадает в webAPI, когда webAPI его обрабатывает он попадает не в call stack, а в очередь (callback queue, FIFO).

Из очереди они попадут в стек после того, как call stack будет полностью очищен и выполнится весь основной код.

События (onClick, onChange) тоже попадают в webAPI и не засоряют call stack;

После итерации event loop мы смотрим нужно ли нам сделать перерисовку страницы, выполняется Render.

[Оглавление - JavaScript 🔼](#menu)

<div id="17"></div>

## 17. Что такое мемоизация и кеширование

**Мемоизация** – сохранение результата каких-либо вычислений, чтобы потом не пересчитывать заново.

**Кеширование** - процесс сохранения данных локально, для быстрого доступа при повторном запросе.

[Оглавление - JavaScript 🔼](#menu)

## Переменные и функции

<div id="18"></div>

## 18. Отличия **var** **let** и **const**?

***Подробнее -*** [Переменные](https://learn.javascript.ru/variables)

В отличие от **var**, область видимости **let** и **const** не функцональная, а блочная. Можно получить доступ к переменным, объявленным с помощью **var**, до их объявления, то есть они всплывают и инициализируются значением **undefined** при создании.

Основное отличие **let** от **const** заключаются в том, что переменным, объявленных с помощью ключевого слова **let**, можно переприсвоить новое значение, а **const** нет. Но если const является обьектом или массивом, то можно изменять внутренние поля

Переменные, определенные с помощью **let** и **const**, также всплывают, но в отличие от **var**, не инициализируются. Мы не можем к ним обращаться, пока не выполнится строка с их определением, будет **ReferenceError**. Это называется "мертвая зона" (temporary dead zone). Когда мы пытаемся обратиться к переменным до того момента как они определены.

C **let** каждому повторению цикла соответствует независимая переменная. При использовании в цикле **var** – одна на все итерации и видна даже после цикла (и блоков {}, кроме функций) т.к глобальная.

```js
for(var i = 0;i < 5; i++){
    setTimeout(function(){
        console.log('count ', i);
    }, 3000);
}
```

При использовании setTimeout() в цикле, console.log будет выполняться только после завершения всех операций в стеке, а значит после того, как все итерации цикла буду выполнены и значение переменной i достигнет цифры 5.

Переменная i объявлена с помощью var. А это означает, что она является глобальной и промежуточные значения такой переменной не будут сохраняться внутри стрелочной функции () => console.log(i).

Таким образом, на экран 5 раз будет выведено значение 5

[Оглавление - JavaScript 🔼](#menu)

<div id="19"></div>

## 19. Функция первого класса

### Функция первого класса
Функции первого класса (First-class functions) — это функции, которые в языке программирования рассматриваются как "граждане первого класса" (first-class citizens). Это значит, что функции можно:

1. **Присваивать переменным:** Функции могут быть сохранены в переменные, точно так же, как любые другие значения.
2. **Передавать как аргументы:** Функции могут передаваться в другие функции как аргументы.
3. **Возвращать как результат:** Функции могут возвращаться из других функций.
4. **Хранить в структурах данных:** Функции могут быть элементами массивов, объектами свойств и т. д.

Пример функции первого класса в JavaScript:

```javascript
function greet(name) {
    return `Hello, ${name}!`;
}

// Присваивание функции переменной
let sayHello = greet;

console.log(sayHello("Alice")); // "Hello, Alice!"

// Передача функции как аргумента
function executeFunction(fn, value) {
    return fn(value);
}

console.log(executeFunction(greet, "Bob")); // "Hello, Bob!"

// Возврат функции как результата
function createGreeter(greeting) {
    return function(name) {
        return `${greeting}, ${name}!`;
    };
}

let greeter = createGreeter("Hi");
console.log(greeter("Charlie")); // "Hi, Charlie!"
```

[Оглавление - JavaScript 🔼](#menu)

<div id="20"></div>

## 20. Стрелочные функции и их отличие от функций, объявленных через function

**Подробнее -** [Стрелочные функции](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Functions/Arrow_functions)

- Синтаксис
- Стрелочные функции не имеют **argumemts**.
- У стрелочных функций нет своего **this**. Если идет обращение к this, то он берется снаружи.
- Не могут быть функциями – конструкторами. Т.е не могут вызываться с помощью new.

[Оглавление - JavaScript 🔼](#menu)

<div id="21"></div>

## 21. function expression и function declaration. Что это такое и в чем разница?

**Function Declaration (Объявление функции)**

Объявление функции определяет функцию с указанным именем. Они объявляются с помощью ключевого слова `function`, за которым следует имя функции.
```js
function greet() {
  console.log("Hello, World!");
}
```
Особенностью объявлений функций является то, что они подвергаются так называемому "всплытию" (hoisting), что позволяет вызывать функцию до ее физического расположения в коде.

**Function Expression (Функциональное выражение)**

Функциональное выражение - это функция, определенная внутри выражения. Они могут быть анонимными и могут быть присвоены переменной.
```js
let greet = function() {
  console.log("Hello, World!");
};
```

Функциональные выражения не подвергаются всплытию, и поэтому функцию нельзя вызвать до ее определения в коде.

Основное различие между ними заключается в том, что function declarations подвергаются всплытию и могут быть вызваны до того, как они были определены, в то время как function expressions не подвергаются всплытию и могут быть вызваны только после их определения.

[Оглавление - JavaScript 🔼](#menu)

<div id="22"></div>

## 22. Что такое анонимная функция?

Анонимная функция - функция, которая была объявлена без какой-либо функции с именем идентификатора, чтобы ссылаться на нее. Обычно она недоступна после ее первоначального создания. Эти функции создаются во время выполнения.

Вот пример анонимной функции в JavaScript:
```js
const greeting = function() {
    console.log("Hello, world!");
};

greeting();  // Вывод: "Hello, world!"
```
В этом примере переменная `greeting` ссылается на анонимную функцию, которая выводит "Hello, world!" в консоль. Функция не имеет имени, поэтому она называется анонимной.

Анонимные функции также часто используются в качестве функций обратного вызова, например:
```js
setTimeout(function() {
    console.log("This message will appear after 1 second");
}, 1000);
```
В этом примере анонимная функция передается в функцию `setTimeout` и будет вызвана через 1 секунду.

[Оглавление - JavaScript 🔼](#menu)

<div id="23"></div>

## 23. Что такое IIFE Самовызывающиеся функции

IIFE (Immediately Invoked Function Expression), или самовызывающаяся функция, — это паттерн в JavaScript, который позволяет выполнить функцию немедленно после её объявления.

IIFE обычно используются для создания области видимости переменных, которые не "загрязняют" глобальную область видимости. Поскольку в JavaScript переменные, объявленные с помощью `var`, ограничены функцией, а не блоком, IIFE используются для симуляции блока области видимости, что предотвращает конфликты имён и помогает изолировать код.

Вот пример IIFE:

```javascript
(function () {
  var temp = "temporary variable";
  console.log(temp);
})();

// temp is not accessible here
console.log(temp); // ReferenceError: temp is not defined
```

В этом примере, переменная `temp` доступна только внутри самовызывающейся функции. Попытка обратиться к `temp` вне этой функции приведёт к ошибке `ReferenceError`.

Стоит отметить, что с появлением ключевых слов `let` и `const` в ES6, которые создают переменные с блочной областью видимости, необходимость в IIFE для изоляции области видимости переменных стала не такой критичной. Однако, IIFE всё ещё полезны в некоторых случаях, например, когда нужно немедленно выполнить некоторый код, не загрязняя глобальную область видимости.

[Оглавление - JavaScript 🔼](#menu)

<div id="24"></div>

## 24. Что такое чистая функция?

**Подробнее –** [Чистая функция](https://habr.com/ru/post/437512/)

Функция должна удовлетворять двум условиям, чтобы считаться «чистой»:

- **Детерминированность** - для одинаковых аргументов чистая функция всегда возвращает одинаковые результаты. То есть, если мы несколько раз вызовем функцию с одним и тем же набором аргументов, результат будет всегда один и тот же

- **Отсутствие побочных эффектов:** - функция не изменяет состояние программы и не влияет на другие части программы

Например, функция, которая возвращает квадрат числа, является чистой функцией:
```js
function square(x) {
  return x * x;
}
```
В этом случае, функция `square` всегда будет возвращать один и тот же результат для одного и того же аргумента, и она не имеет побочных эффектов, так как не изменяет внешнее состояние и не меняет свой аргумент.

[Оглавление - JavaScript 🔼](#menu)

<div id="25"></div>

## 25. Что такое функция высшего порядка?

**Подробнее –** [Функции высшего порядка](https://habr.com/ru/post/261723/)

Функция высшего порядка (Higher-Order Function, HOF) — это функция, которая может принимать другую функцию в качестве аргумента или возвращать другую функцию в качестве результата.

```js
function greet(name, formatter) {
  return "Hello, " + formatter(name);
}

function upperCaseName(name) {
  return name.toUpperCase();
}

console.log(greet("John", upperCaseName)); // Выводит: "Hello, JOHN"
```
В этом примере функция `greet` принимает функцию `formatter` в качестве аргумента и вызывает её внутри себя.

Функции высшего порядка очень распространены в JavaScript, особенно с функциями-обратными вызовами (callbacks) и встроенными методами массивов, такими как `map`, `filter`, `reduce` и другими.

[Оглавление - JavaScript 🔼](#menu)

<div id="26"></div>

## 26. Что такое каррирование (функция карри)?

Каррирование (currying) — это процесс преобразования функции с множеством аргументов в последовательность функций, каждая из которых имеет только один аргумент.

Если взять простой пример, обычная функция `sum` может принимать два аргумента и возвращать их сумму:
```js
function sum(a, b) {
    return a + b;
}

console.log(sum(1, 2)); // 3
```

Та же функция после каррирования будет выглядеть так:
```js
function sum(a) {
    return function(b) {
        return a + b;
    }
}

console.log(sum(1)(2)); // 3
```
Как видите, после каррирования функция `sum` принимает один аргумент и возвращает другую функцию, которая также принимает один аргумент. Это позволяет применять аргументы по одному, что может быть полезно в некоторых сценариях.

Кроме того, многие функциональные языки программирования поддерживают автоматическое каррирование, и есть библиотеки (например, lodash в JavaScript), которые предоставляют функции для каррирования существующих функций.

[Оглавление - JavaScript 🔼](#menu)

<div id="27"></div>

## 27. Как отслеживать и обрабатывать ошибки в javascript? `Try/Catch/Finally`

**Подробнее -** [Обработка ошибок](https://learn.javascript.ru/try-catch)

1.  **Try/Catch/Finally**: Это основной механизм обработки ошибок в JavaScript. Блок `try` содержит код, который может вызвать ошибку, `catch` перехватывает ошибку, если она произошла, и `finally` выполняется после выполнения кода в `try` и `catch`, независимо от того, была ли ошибка.

```js
try {
  // код, который может вызвать ошибку
} catch (error) {
  // обработка ошибки
} finally {
  // код, который будет выполнен в любом случае
}
```

2.  **Обработка ошибок в промисах**: Промисы в JavaScript предоставляют методы `then` и `catch` для обработки успешного выполнения и ошибок соответственно. Вы можете добавить `catch` в конец цепочки промисов для перехвата любых ошибок, которые могут произойти в любом из предыдущих промисов.

```js
doSomethingAsync()
  .then(result => doSomethingElseAsync(result))
  .catch(error => console.error('An error occurred:', error));
```

3.  **Обработка ошибок с async/await**: Когда вы используете async/await, вы можете использовать try/catch для обработки ошибок, которые могут произойти в промисах.

```js
async function doSomethingAsync() {
  try {
    let result = await someAsyncOperation();
    // do something with result
  } catch (error) {
    console.error('An error occurred:', error);
  }
}
```

<div id="28"></div>

## 28. Что такое рекурсия? Как предотвратить бесконечную рекурсию?

**Подробнее –** [Рекурсия](https://learn.javascript.ru/recursion)

Рекурсия — это такой способ организации обработки данных, при котором программа вызывает сама себя непосредственно, либо с помощью других программ.

Рекурсивная функция состоит из:

- Условие остановки или же Базовый случай
- Условие продолжения или Шаг рекурсии — способ сведения задачи к более простым.

Базовый случай является обязательным условием, иначе произойдет переполнения стека вызовов из за бесконечного вызова функции.

Вот простейший пример рекурсии на JavaScript - вычисление факториала числа:
```js
function factorial(n) {
  if (n === 0) {
    return 1;
  } else {
    return n * factorial(n - 1);
  }
}

console.log(factorial(5));  // Вывод: 120
```
В этом примере функция `factorial` вызывает саму себя для вычисления факториала числа.

[Оглавление - JavaScript 🔼](#menu)

[Оглавление - JavaScript 🔼](#menu)

## Объекты и прототипы

<div id="29"></div>

## 29. Что такое прототипное наследование?

**Подробнее -** [Прототипное наследование](https://learn.javascript.ru/prototype-inheritance)

Изначально каждый объект в javascript обладает свойством — прототипом. Вы можете добавлять в него методы и свойства. На основе прототипа можно создавать другие объекты. Создаваемый объект автоматически унаследует свойства и своего прототипа. Если свойство в новом объекте отсутствует, то будет произведен его поиск в прототипе.

[Оглавление - JavaScript 🔼](#menu)

<div id="30"></div>

## 30. Что такое прототип объекта в JavaScript? `Prototype`

Прототип объекта в JavaScript - это механизм, который позволяет объектам наследовать свойства и методы других объектов. Это основа прототипного наследования в JavaScript.

Каждый объект в JavaScript имеет внутреннее свойство `[[Prototype]]`, которое является ссылкой на другой объект, известный как прототип этого объекта. Когда вы пытаетесь получить доступ к свойству или методу объекта, и JavaScript не может найти его в самом объекте, он ищет это свойство или метод в прототипе объекта. Если и там его не находит, то переходит к прототипу прототипа и так далее, пока не дойдет до `null`, который является прототипом всех объектов и не имеет своего собственного прототипа. Этот процесс называется цепочкой прототипов.

Вы можете получить доступ к прототипу объекта с помощью метода `Object.getPrototypeOf()` или свойства `__proto__`, хотя последнее считается устаревшим и не рекомендуется к использованию.

Также можно установить прототип объекта при его создании с помощью `Object.create(proto)`, где `proto` - это объект, который должен стать прототипом нового объекта.

Прототипы позволяют объектам делиться методами, что может сэкономить память и упростить код. Они также являются ключевым механизмом для реализации наследования и повторного использования кода в JavaScript.

---

В JavaScript прототипы реализуются через свойство `prototype` функции-конструктора или через метод `Object.create()`. Когда объект создается с использованием функции-конструктора или метода `Object.create()`, его прототипом становится прототип функции-конструктора или объекта-прототипа, соответственно.

Для создания методов объекта можно использовать прототипы. Примеры создания методов:

1. Через свойство `prototype` функции-конструктора:
```javascript
function Person(name) {
  this.name = name;
}

Person.prototype.sayHello = function() {
  console.log("Hello, my name is " + this.name);
};

var person = new Person("John");
person.sayHello(); // Выводит: "Hello, my name is John"
```

2. Через метод `Object.create()`:
```javascript
var personPrototype = {
  sayHello: function() {
    console.log("Hello, my name is " + this.name);
  }
};

var person = Object.create(personPrototype);
person.name = "John";
person.sayHello(); // Выводит: "Hello, my name is John"
```

3. С помощью классов (введенных в ECMAScript 2015):
```javascript
class Person {
  constructor(name) {
    this.name = name;
  }

  sayHello() {
    console.log("Hello, my name is " + this.name);
  }
}

var person = new Person("John");
person.sayHello(); // Выводит: "Hello, my name is John"
```

Во всех трех примерах `sayHello()` - это метод объекта `person`, который был создан с использованием прототипа. Объекты, созданные на основе этого прототипа, наследуют этот метод и могут вызывать его.

[Оглавление - JavaScript 🔼](#menu)

<div id="31"></div>

## 31. Какие способы создания объекта вы знаете?

В JavaScript существует несколько способов создания объектов:

1.  **Литерал объекта**: Это наиболее простой и распространенный способ создания объекта.
```js
let obj = {
  key1: 'value1',
  key2: 'value2'
};
```

2.  **Конструктор `Object`**: Вы также можете создать объект с помощью глобального конструктора `Object`.
```js
let obj = new Object();
```

3.  **Функция-конструктор**: Вы можете определить собственную функцию-конструктор и использовать ее для создания объектов.
```js
function MyObject(key, value) {
  this.key = key;
  this.value = value;
}

let obj = new MyObject('key', 'value');
```

4.  **Метод `Object.create`**: Этот метод создает новый объект с указанным объектом-прототипом.
```js
let prototypeObj = {
  key: 'value'
};

let obj = Object.create(prototypeObj);
```

5.  **Классы ES6**: С введением ES6 (ECMAScript 2015) появилась поддержка классов, что предоставляет еще один способ создания объектов.
```js
class MyClass {
  constructor(key, value) {
    this.key = key;
    this.value = value;
  }
}

let obj = new MyClass('key', 'value');
```

[Оглавление - JavaScript 🔼](#menu)

<div id="32"></div>

## 32. Как сделать обьект неизменяемым, методы `Object.freeze`, `Object.seal`, `Object.defineProperty`

1. **`Object.freeze(obj)`** – делает обьект **readonly**, предотвращает добавление свойств, нельзя менять свойства.  После применения этого метода, нельзя добавить, удалить или изменить свойства объекта.
2. **`Object.seal(obj)`** - делает объект o нерасширяемым (Object.preventExtensions()), а все его собственные свойства – ненастраиваемыми. Это предотвращает добваление новых свойств и удаление существующих. Можно изменять существующие свойства
3. **`Object.defineProperty(obj, propertyName, descriptor)`** - определяет новое или изменяет существующее свойство в объекте, возвращая этот объект. **Descriptor** – обьект со свойствами `configurable` (можем менять),
`enumerable` (можем ли итерироваться), `writetable` (можем ли присвоить значение или же свойство readonly), `value`.
пример:
```js
const object1 = {};

Object.defineProperty(object1, 'property1', {
  value: 42,
  writable: false,
});

object1.property1 = 77;
// Throws an error in strict mode

console.log(object1.property1);
// Expected output: 42
```
4. **`Object.defineProperties`** - определяет новые или изменяет существующие свойства, непосредственно на объекте, возвращая этот объект.
пример:
```js
Object.defineProperties(obj, {
  property1: {
    value: true,
    writable: true,
  },
  property2: {
    value: "Hello",
    writable: false,
  },
  // и т.д.
});
```

[Оглавление - JavaScript 🔼](#menu)

<div id="33"></div>

## 33. Что такое деструктуризация?

Деструктуризация в JavaScript — удобный синтаксис, который позволяет извлечь данные из массивов или объектов непосредственно в отдельные переменные.

1.  **Деструктуризация массивов**:
```js
let arr = [1, 2, 3];
let [a, b, c] = arr;

console.log(a); // 1
console.log(b); // 2
console.log(c); // 3
```

2.  **Деструктуризация объектов**:
```js
let obj = { name: 'John', age: 30 };
let { name, age } = obj;

console.log(name); // 'John'
console.log(age);  // 30
```

3.  **Деструктуризация в параметрах функции**:
```js
function greet({ name, age }) {
  console.log(`Hello, ${name}. You are ${age} years old.`);
}

greet({ name: 'John', age: 30 });  // 'Hello, John. You are 30 years old.'
```

Деструктуризация особенно полезна, когда у вас есть функция, которая возвращает массив или объект, и вы хотите использовать эти данные в своем коде. Она делает код более чистым и понятным, сокращает количество строк кода и уменьшает вероятность ошибок.

[Оглавление - JavaScript 🔼](#menu)

<div id="34"></div>

## 34. Как определить наличие свойства в объекте?

**Подробнее -** [hasOwnProperty](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty)

В JavaScript для проверки наличия свойства в объекте можно использовать несколько подходов:

1.  **Оператор `in`**: Он возвращает `true`, если указанное свойство находится в указанном объекте или его прототипе.
```js
let obj = {key: 'value'};
console.log('key' in obj); // true
console.log('nonExistingKey' in obj); // false
```
2.  **Метод `hasOwnProperty`**: Этот метод возвращает `true`, если объект содержит указанное свойство как собственное (то есть оно не унаследовано).
```js
let obj = {key: 'value'};
console.log(obj.hasOwnProperty('key')); // true
console.log(obj.hasOwnProperty('nonExistingKey')); // false
```

[Оглавление - JavaScript 🔼](#menu)

<div id="35"></div>

## 35. Как получить свойство объекта? `Object.keys, Object.values, Object.entries`

**Подробнее -** [Объекты](https://developer.mozilla.org/ru/docs/Web/JavaScript/Guide/Working_with_Objects)

1.  **Через точечную нотацию**: Вы можете получить доступ к свойству объекта, используя имя объекта, затем точку, затем имя свойства.
```js
let obj = { name: "John", age: 30 };
console.log(obj.name); // "John"
```
2.  **Через квадратные скобки**: Вы также можете получить доступ к свойству объекта, используя квадратные скобки. Этот способ полезен, когда имя свойства хранится в переменной или когда имя свойства содержит пробелы или специальные символы.
```js
let obj = { name: "John", age: 30 };
let propName = "name";
console.log(obj[propName]); // "John"
```
3.  **Через метод `Object.getOwnPropertyDescriptor`**: Этот метод позволяет получить метаданные о свойстве, включая его значение, настройки перечислимости, настройки записи и настройки конфигурации.
```js
let obj = { name: "John", age: 30 };
let descriptor = Object.getOwnPropertyDescriptor(obj, 'name');
console.log(descriptor.value); // "John"
```

---

так же есть методы **`Object.keys`**, **`Object.values`** , **`Object.entries`**

1.  **Object.keys()**: Этот метод возвращает массив, содержащий имена (или "ключи") всех собственных перечисляемых свойств объекта.
```js
let obj = { name: "John", age: 30, city: "New York" };
console.log(Object.keys(obj)); // ["name", "age", "city"]
```
2.  **Object.values()**: Этот метод возвращает массив, содержащий значения всех собственных перечисляемых свойств объекта.
```js
let obj = { name: "John", age: 30, city: "New York" };
console.log(Object.values(obj)); // ["John", 30, "New York"]
```
3.  **Object.entries()**: Этот метод возвращает массив массивов. Каждый внутренний массив представляет собой пару [ключ, значение] для каждого собственного перечисляемого свойства объекта.
```js
let obj = { name: "John", age: 30, city: "New York" };
console.log(Object.entries(obj)); // [["name", "John"], ["age", 30], ["city", "New York"]]
```

[Оглавление - JavaScript 🔼](#menu)

<div id="36"></div>

## 36. Дескрипторы свойств объекта

ссылка на подробную инфу - https://doka.guide/js/descriptors/

### Дескриптор данных

Дескриптор описывает свойство, которое хранит значение. Дескриптор данных может содержать следующие атрибуты:

- **`value`**: Значение свойства. По умолчанию `undefined`.
- **`writable`**: Булевое значение, указывающее, доступно ли свойство для записи;. По умолчанию `true`.
- **`enumerable`**: Булевое значение, указывающее, будет ли свойство перечисляться в цикле `for...in` и методах, таких как `Object.keys()`. По умолчанию `true`.
- **`configurable`**: Булевое значение, указывающее, можно ли удалить свойство или изменить его атрибуты, кроме `value`. По умолчанию `true`.

Для изменения значений дескрипторов применяется статический метод **`Object.defineProperty()`**, а для чтения значений — **`Object.getOwnPropertyDescriptors()`**.

Другими словами, дескрипторы — это пары ключ-значение, которые описывают поведение свойства объекта при выполнении операций над ним (например, чтения или записи).

Пример использования дескриптора данных:

```javascript
let obj = {};
Object.defineProperty(obj, 'name', {
  value: 'John',
  writable: true,
  enumerable: true,
  configurable: true
});
```

[Оглавление - JavaScript 🔼](#menu)

<div id="37"></div>

## 37. Что такое объект `Proxy`

Объект `Proxy` позволяет обернуть другой объект и может перехватывать и обрабатывать разные действия с ним, например, чтение/запись свойств, вызов функций, удаление свойств, проверку наличия свойств и другие операции. Он создается с помощью конструктора `new Proxy(target, handler)`, где `target` — это целевой объект, а `handler` — объект, содержащий "ловушки" (`traps`) для перехвата операций.

Например, вот как можно создать прокси-объект, который перехватывает операцию чтения свойства `name` целевого объекта `user`:

```javascript
let user = {
    name: "Alice",
    age: 30
};

let handler = {
    get: function(target, property) {
        if (property === 'name') {
            return `Hello, ${target[property]}!`;
        }
        return target[property];
    }
};

let proxy = new Proxy(user, handler);

console.log(proxy.name); // "Hello, Alice!"
console.log(proxy.age);  // 30
```

В этом примере, когда происходит попытка прочитать свойство `name` через прокси, `handler.get` перехватывает это действие и возвращает модифицированное значение `"Hello, Alice!"`. Для других свойств прокси просто возвращает значения из целевого объекта `user` без изменений.

[Оглавление - JavaScript 🔼](#menu)

<div id="38"></div>

## 38. Как работает ключевое слово new

**Ключевое слово new** - создает экземпляр обьекта, при этом вызывая конструктор. При вызове **new** создаётся новый пустой объект который наследуется от **Object**, и он присваивается **this**. Выполняется тело функции. Обычно оно как-то модифицирует **this**. Далее возвращается значение **this**.

[Оглавление - JavaScript 🔼](#menu)

<div id="39"></div>

## 39. Как сделать наследование класса в ES6

**Подробнее -** [Классы](https://learn.javascript.ru/class)

**Подробнее -** [Наследование](https://learn.javascript.ru/class-inheritance)

Расширение\наследование класса происходит с помощью ключевого слова extends, после которого идет название родительского класса. Например:
```js
class Animal {
  constructor(name) {
    this.name = name;
  }

  speak() {
    console.log(this.name + ' makes a noise.');
  }
}

class Dog extends Animal {
  speak() {
    console.log(this.name + ' barks.');
  }
}

let dog = new Dog('Rex');
dog.speak(); // Rex barks.
```
В этом примере класс `Dog` наследует от класса `Animal` с помощью ключевого слова `extends`. Затем в классе `Dog` переопределяется метод `speak`.

[Оглавление - JavaScript 🔼](#menu)

<div id="40"></div>

## 40. Конструкторы, constructor

**Конструкторы** — это функции, которые используются для создания новых объектов. Когда функция конструктор вызывается с оператором **`new`**, она создает новый объект и инициализирует его свойства.

[Оглавление - JavaScript 🔼](#menu)

<div id="41"></div>

## 41. Как проверить, из какого класса был создан объект?

**Подробнее –** [Оператор instanceof](https://learn.javascript.ru/instanceof)

Для проверки, из какого класса был создан объект, можно использовать оператор `instanceof`
- Использование `instanceof`:
```js
class MyClass {}
let myInstance = new MyClass();

console.log(myInstance instanceof MyClass); // Вернёт true
```
В этом примере оператор `instanceof` проверяет, является ли `myInstance` экземпляром класса `MyClass`.

[Оглавление - JavaScript 🔼](#menu)

<div id="42"></div>

## 42. Что такое статический метод класса (static)?

Статические методы - это методы, определенные на самом классе, а не на экземплярах класса. Они вызываются без создания экземпляра класса и не могут быть вызваны через экземпляр класса. Статические методы часто используются для создания вспомогательных функций для приложения.

В JavaScript статические методы объявляются с ключевым словом `static`.

Пример:
```js
class MyClass {
  static myStaticMethod() {
    return 'Hello, I am a static method!';
  }
}

console.log(MyClass.myStaticMethod());
// Вывод: 'Hello, I am a static method!'
```

В этом примере, `myStaticMethod` является статическим методом класса `MyClass`. Этот метод может быть вызван непосредственно из класса, как показано в `console.log(MyClass.myStaticMethod())`, и он не требует создания экземпляра `MyClass`.

Если попытаться вызвать статический метод через экземпляр класса, вы получите ошибку:
```js
let myInstance = new MyClass();
console.log(myInstance.myStaticMethod());
// TypeError: myInstance.myStaticMethod is not a function
```
Таким образом, статические методы обычно используются для функций, которые не требуют доступа к свойствам экземпляра класса, но все равно логически связаны с классом.

[Оглавление - JavaScript 🔼](#menu)

<div id="43"></div>

## 43. Почему два объекта с одинаковыми полями при сравнении дают false?

**Подробнее –** [Сравнение по ссылке](https://learn.javascript.ru/object-copy%23sravnenie-po-ssylke)

```js
const a = {key: 5}
const b = {key: 5}

a === b // false
```
Объекты сравниваются по ссылкам на область в памяти. С точки зрения JavaScript объекты a и b разные, хотя и имеют одинаковые поля. Объекты равны только в том случае, если это один и тот же объект.

[Оглавление - JavaScript 🔼](#menu)

<div id="44"></div>

## 44. Что такое делегирование событий в JS?

Вместо того чтобы назначать обработчик каждому элементу вручную, вы назначаете один обработчик родительскому элементу. Этот обработчик затем может обрабатывать события от любого дочернего элемента, используя фазу всплытия события.

Делегирование событий очень полезно в ситуациях, когда у вас много элементов, которым нужно обрабатывать одно и то же событие, или когда элементы динамически добавляются или удаляются из DOM.

Пример делегирования событий:
 ```js
 document.querySelector('ul').addEventListener('click', function(event) {
  if (event.target.tagName.toLowerCase() === 'li') {
    console.log(event.target.textContent);
  }
});
```

В этом примере обработчик событий "click" назначается родительскому элементу `<ul>`. Затем, когда происходит клик, обработчик проверяет, был ли элемент, по которому был совершен клик (`event.target`), элементом `<li>`. Если да, то он выводит текст этого элемента.

Таким образом, можно обрабатывать клики на любом количестве дочерних элементов `<li>`, используя всего один обработчик событий, а также спокойно добавлять или удалять элементы `<li>`, и обработчик будет корректно работать со всеми существующими на момент клика элементами.

[Оглавление - JavaScript 🔼](#menu)

<div id="45"></div>

## 45. Как удалить ключ у объекта?

Для удаления ключа (свойства) из объекта в JavaScript используется оператор `delete`. Этот оператор удаляет свойство из объекта, не изменяя другие свойства.

### Синтаксис

```javascript
delete object.property;
```

или

```javascript
delete object['property'];
```

- **`object`**: Объект, из которого удаляется свойство.
- **`property`**: Имя свойства, которое нужно удалить.

### Пример использования

```javascript
const person = {
  name: 'John',
  age: 30,
  occupation: 'Developer'
};

// Удаление свойства age
delete person.age;

console.log(person);
// { name: 'John', occupation: 'Developer' }

// Удаление свойства occupation
delete person['occupation'];

console.log(person);
// { name: 'John' }
```

В этом примере из объекта `person` удаляются свойства `age` и `occupation`, и они больше не существуют в объекте.

### Особенности и ограничения

1. **Удаление несуществующего свойства**:
   - Если попытаться удалить свойство, которого нет в объекте, операция `delete` просто ничего не сделает и не вызовет ошибку.

   ```javascript
   delete person.nonExistentProperty; // Ничего не происходит
   ```

2. **Работа с `configurable` свойствами**:
   - Только свойства с атрибутом `configurable: true` могут быть удалены. По умолчанию свойства, добавленные через литералы объектов или с помощью оператора присваивания, являются настраиваемыми (`configurable: true`).

   ```javascript
   Object.defineProperty(person, 'name', {
     configurable: false,
     value: 'John'
   });

   delete person.name; // Ничего не произойдет
   console.log(person.name); // 'John'
   ```

   В этом примере свойство `name` не может быть удалено, потому что оно не конфигурируемое.

[Оглавление - JavaScript 🔼](#menu)



## Работа с событиями

<div id="47"></div>

## 47. `e.preventDefault()` и `e.stopPropagation()`, `e.stopImmediatePropagation` для чего нужны?

**Подробнее -** [действия браузера по умолчанию](https://learn.javascript.ru/default-browser-action)

**Подробнее -** [Всплытие и погружение](https://learn.javascript.ru/bubbling-and-capturing)

1. **`e.preventDefault()`** используется для предотвращения стандартного поведения браузера в ответ на событие. Например, если вы хотите предотвратить переход по ссылке при клике на нее, вы можете использовать `e.preventDefault()` в обработчике события клика.

```js
document.querySelector('a').addEventListener('click', function(e) {
  e.preventDefault();
  console.log('Link clicked!');
});
```
В этом примере, когда пользователь кликает на ссылку, вместо перехода по ссылке, браузер останавливает стандартное поведение и выводит сообщение "Link clicked!" в консоль.

2. **`e.stopPropagation()`** используется для предотвращения распространения события дальше по дереву DOM. События в JavaScript по умолчанию всплывают от элемента, который сгенерировал событие, к его родителям, пока не достигнут верхнего уровня дерева. Использование `e.stopPropagation()` останавливает это всплытие.

```js
document.querySelector('button').addEventListener('click', function(e) {
  e.stopPropagation();
  console.log('Button clicked!');
});
```
В этом примере, когда пользователь кликает на кнопку, событие "click" не будет всплывать выше по дереву DOM, и обработчики событий "click" родительских элементов не будут срабатывать.

3. `e.stopImmediatePropagation()`** делает то же самое, что и stopPropagation, но, в том числе, предотвращает вызов обработчиков события, которые были установлены на этом же элементе.

[Оглавление - JavaScript 🔼](#menu)

<div id="48"></div>

## 48. Всплытие и погружение событий. `bubbling, capturing`

**Подробнее -** [Всплытие и погружение](https://learn.javascript.ru/bubbling-and-capturing)

**Всплытие (bubbling)**: Принцип всплытия очень простой. Когда на элементе происходит событие, обработчики сначала срабатывают на нём, потом на его родителе, затем выше и так далее, вверх по цепочке предков.

Всплытие позволяет делегировать события, повесив обработчик события на родительский элемент, мы можем обрабатывать клики по дочерним элементам.

```html
<form onclick="alert('form')">FORM
	<div onclick="alert('div')">DIV
		<p onclick="alert('p')">P</p>
	</div>
</form>
```
В данном примере алерты появятся в следующей последовательности
`p -> div -> form`

---

**Погружение (capturing)**: Погружение - это процесс, который происходит перед всплытием, когда событие спускается от корневого элемента дерева DOM до элемента, вызвавшего событие. Однако, по умолчанию обработчики не реагируют на этап погружения. Чтобы обработчик срабатывал на этапе погружения, нужно установить третий аргумент метода `addEventListener` в `true`.

```js
div.addEventListener('click', function() { alert('div'); }, true); // capturing phase
button.addEventListener('click', function() { alert('button'); }, true); // capturing phase
```
Таким образом, когда происходит событие, оно сначала спускается вниз по дереву DOM (фаза погружения), затем всплывает вверх (фаза всплытия). Это называется "фазой погружения и всплытия" или "фазой захвата и всплытия".

[Оглавление - JavaScript 🔼](#menu)

<div id="49"></div>

## 49. Отличие Event.target от event.currentTarget

**Event.target** — это элемент, в котором происходит событие, или элемент, вызвавший событие.

**Event.currentTarget** — это элемент, к которому прикреплен прослушиватель событий.

[Оглавление - JavaScript 🔼](#menu)

<div id="50"></div>

## 50. Optional chaining оператор. Для чего нужен?

**Подробнее -** [Опциональная цепочка](https://learn.javascript.ru/optional-chaining)
**Видео пример -** [видео](https://youtu.be/fcS4azdSR_0)

Например, рассмотрим объекты для пользователей user. У большинства пользователей есть адрес user.address с улицей user.address.street, но некоторые адрес не указали.

В этом случае при попытке получить свойство user.address.street будет ошибка:
```js
let user = {}; // пользователь без адреса

console.log(user.address.street); // ошибка!
```
Опциональная цепочка **?.** останавливает вычисление и возвращает undefined, если часть перед **?.** имеет значение undefined или null.
```js
let user = {}; // пользователь без адреса

console.log(user?.address?.street); // undefined (без ошибки)
```

<div id="51"></div>

## 51. Что такое throttle и debounce

`Throttle` и `Debounce` - это две техники, которые широко используются в JavaScript, чтобы контролировать, как часто мы вызываем функцию в течение определенного периода времени. Они особенно полезны при оптимизации производительности в ситуациях, когда некоторые коды могут вызываться чаще, чем нужно.

**Throttle**

Throttle ограничивает количество раз, когда функция может быть вызвана, до определенного количества раз в заданный период времени. Это похоже на торможение в автомобиле — вы не можете превысить определенную скорость, независимо от того, насколько быстро вы нажимаете на педаль газа.

Это полезно, например, для обработчиков событий скроллинга, где вы хотите обновить интерфейс, но ограничивать частоту обновления, чтобы уменьшить нагрузку на браузер.

**Debounce**

Debounce гарантирует, что функция не будет вызываться снова, пока не пройдет определенное количество времени с момента ее последнего вызова. Это похоже на "отскок" в электронике, где вы хотите игнорировать множественные сигналы до тех пор, пока не пройдет некоторое время с момента последнего сигнала.

Это полезно, например, для обработчиков событий ввода, где вы хотите ждать, пока пользователь закончит вводить текст, прежде чем выполнять поиск или валидацию.

Важно отметить, что эти две техники имеют разные цели и должны использоваться в разных сценариях, в зависимости от желаемого поведения.

[Оглавление - JavaScript 🔼](#menu)

<div id="52"></div>

## 52. Как остановить интервал? `clearInterval(intervalId)`

**Подробнее –** [остановить интервал](https://puzzleweb.ru/javascript/window_clearinterval.php)

Для остановки интервала предназначена функция clearInterval. Пример кода представлен ниже.
```js
let time = 0;

let intervalId = setInterval(() => {
  time += 5;
  console.log(`Вы провели на сайте ${time} секунд.`);
}, 5000);

// Предположим, мы хотим остановить интервал после 30 секунд
setTimeout(() => {
  clearInterval(intervalId);
}, 30000);
```

[Оглавление - JavaScript 🔼](#menu)

## Асинхронность и запросы.

<div id="53"></div>

## 53. Что такое `requestAnimationFrame`?

`requestAnimationFrame` — это встроенный метод JavaScript, предназначенный для оптимизации анимаций и визуальных изменений на веб-странице. Он позволяет браузеру синхронизировать обновления экрана с частотой обновления монитора, что делает анимации плавными и эффективными.

### Основные особенности `requestAnimationFrame`:

1. **Синхронизация с обновлением экрана**:
   `requestAnimationFrame` позволяет браузеру оптимально обновлять анимации, синхронизируя их с частотой обновления экрана (обычно 60 раз в секунду). Это помогает избежать резких изменений и "дёргания" анимаций.

2. **Производительность**:
   Метод позволяет эффективно управлять анимацией, минимизируя нагрузку на процессор и улучшая производительность, так как он запускается только когда браузер готов к следующему кадру анимации.

3. **Отмена запроса**:
   Возвращаемое значение `requestAnimationFrame` можно использовать для отмены анимации с помощью `cancelAnimationFrame`, если требуется остановить её до завершения.

### Как использовать `requestAnimationFrame`:

```javascript
function animate() {
    // Логика анимации
    console.log('Animating...');

    // Запрашиваем следующий кадр анимации
    requestAnimationFrame(animate);
}

// Начинаем анимацию
requestAnimationFrame(animate);
```

### Пример использования `requestAnimationFrame`:

1. **Плавное перемещение элемента:**

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>requestAnimationFrame Example</title>
    <style>
        #box {
            width: 50px;
            height: 50px;
            background-color: red;
            position: absolute;
        }
    </style>
</head>
<body>
    <div id="box"></div>
    <script>
        const box = document.getElementById('box');
        let start = null;

        function animate(timestamp) {
            if (!start) start = timestamp;
            const progress = timestamp - start;

            // Перемещаем элемент вправо
            box.style.transform = `translateX(${Math.min(progress / 2, 500)}px)`;

            if (progress < 1000) {
                requestAnimationFrame(animate);
            }
        }

        requestAnimationFrame(animate);
    </script>
</body>
</html>
```

### Параметры и использование:

- **Функция обратного вызова (callback)**: `requestAnimationFrame` принимает функцию обратного вызова, которая будет вызвана перед следующим обновлением экрана. Эта функция получает временную метку в качестве аргумента, которая указывает, когда был вызван `requestAnimationFrame`.

- **Время выполнения**: Метод `requestAnimationFrame` передает временную метку функции обратного вызова, что позволяет отслеживать время выполнения анимации и создавать эффекты, зависящие от времени.

- **Отмена анимации**: Если нужно остановить анимацию до завершения, можно использовать `cancelAnimationFrame` с идентификатором, возвращаемым `requestAnimationFrame`.

```javascript
let animationId = requestAnimationFrame(animate);

// Для отмены анимации
cancelAnimationFrame(animationId);
```

### Заключение:

`requestAnimationFrame` является мощным инструментом для создания плавных и производительных анимаций на веб-страницах. Он позволяет браузеру эффективно управлять обновлением анимаций и оптимизировать производительность, синхронизируя их с частотой обновления экрана.

[Оглавление - JavaScript 🔼](#menu)

<div id="54"></div>

## 54. Что такое `requestIdleCallback`?

`requestIdleCallback` — это метод JavaScript, который позволяет выполнять фоновую работу, когда основной поток выполнения не занят. Он дает возможность браузеру использовать свободное время для выполнения не срочных задач, таких как обработка данных, улучшение производительности или обновление интерфейса, не мешая пользовательскому взаимодействию.

### Основные особенности `requestIdleCallback`:

1. **Выполнение в свободное время**:
   `requestIdleCallback` планирует выполнение функции обратного вызова на время, когда основной поток выполнения свободен. Это помогает улучшить производительность и отзывчивость веб-приложений.

2. **Параметры функции обратного вызова**:
   Функция обратного вызова получает объект `IdleDeadline`, который содержит информацию о времени, оставшемся до того, как браузер будет снова занят важными задачами. Вы можете использовать это время для выполнения менее срочных операций.

3. **Отмена выполнения**:
   `requestIdleCallback` возвращает идентификатор, который можно использовать для отмены запланированного выполнения с помощью `cancelIdleCallback`.

### Синтаксис:

```javascript
requestIdleCallback(callback, options);
```

- **`callback`**: Функция обратного вызова, которая будет вызвана, когда браузер будет свободен.
- **`options`** (необязательный): Объект с параметрами:
  - **`timeout`**: Максимальное время в миллисекундах, через которое выполнение функции обратного вызова будет принудительно запланировано, если браузер не сможет найти достаточно времени для выполнения.

### Пример использования:

```javascript
function performNonEssentialTasks(deadline) {
    while ((deadline.timeRemaining() > 0 || deadline.didTimeout) && someTaskList.length > 0) {
        let task = someTaskList.shift();
        // Выполнение задачи
        task();
    }

    if (someTaskList.length > 0) {
        // Если еще есть задачи, запланируйте следующую итерацию
        requestIdleCallback(performNonEssentialTasks);
    }
}

// Запускаем выполнение фоновых задач
requestIdleCallback(performNonEssentialTasks);
```

### Параметры `IdleDeadline`:

- **`timeRemaining()`**: Метод возвращает количество времени в миллисекундах, которое остается до того, как браузер будет снова занят. Это помогает понять, сколько времени у вас есть для выполнения задач.
- **`didTimeout`**: Логическое значение, указывающее, был ли вызов функции обратного вызова в результате истечения времени ожидания (т.е. если задан параметр `timeout`).

### Примеры использования:

1. **Оптимизация интерфейса пользователя**:

```javascript
function updateUI() {
    // Обновление интерфейса может занимать некоторое время
}

requestIdleCallback(() => {
    updateUI();
});
```

2. **Фоновая обработка данных**:

```javascript
function processLargeDataset(deadline) {
    while ((deadline.timeRemaining() > 0 || deadline.didTimeout) && moreDataToProcess()) {
        // Обработка данных
        processDataChunk();
    }

    if (moreDataToProcess()) {
        requestIdleCallback(processLargeDataset);
    }
}

// Начинаем обработку данных
requestIdleCallback(processLargeDataset);
```

### Переход на другие методы:

В современных браузерах `requestIdleCallback` может не поддерживаться в старых версиях или иметь ограниченную поддержку. В таких случаях можно использовать альтернативные методы для управления фоновой задачей, такие как `setTimeout` с большим интервалом или использование `requestAnimationFrame` в сочетании с управлением временем.

### Заключение:

`requestIdleCallback` предоставляет способ выполнения задач в моменты, когда браузер не занят срочными задачами, что помогает улучшить производительность и отзывчивость веб-приложений, особенно при выполнении фоновых операций.

[Оглавление - JavaScript 🔼](#menu)

<div id="55"></div>

## 55. функция `fetch()`

С помощью функции **`fetch()`** можно отправлять сетевые запросы на сервер — как получать, так и отправлять данные. Метод возвращает промис с объектом ответа, где находится дополнительная информация (статус ответа, заголовки) и ответ на запрос.

### Как пишется

Функция fetch() принимает два параметра:
- `url` — адрес, по которому нужно сделать запрос;
- `options` (необязательный) — объект конфигурации, в котором можно настроить метод и тело запроса, заголовки и многое другое.
По умолчанию вызов `fetch()` делает GET-запрос по указанному адресу. Базовый вызов для получения данных можно записать таким образом:
```js
fetch('http://jsonplaceholder.typicode.com/posts')
```

Результатом вызова `fetch()` будет Promise, в котором содержится специальный объект ответа `Response`. У этого объекта есть два важных для нас поля:

`ok` — принимает состояние `true` или `false` и сообщает об успешности запроса;
`json` — метод, вызов которого, возвращает результат запроса в виде `JSON`.
В следующем примере используем `.then()` — обработчик результата, полученного от асинхронной операции. Обработчик дождётся ответа от сервера, принимает ответ, и, в данном случае, неявно вернёт ответ, обработанный методом `.json()`.

В примере функция `then` вернёт другой промис (их можно объединять). Когда отрезолвится промис `(r.json())`, который вернула функция `then`, будет вызван следующий колбэк в цепочке.
```js
fetch('http://jsonplaceholder.typicode.com/posts')
  .then((response) => response.json()
  // Получим ответ в виде массива из объектов:
  // [{...}, {...}, {...}, ...]
)
```

С помощью второго аргумента `options` можно передать настройки запроса. Например, можно изменить метод и добавить тело запроса, если мы хотим не получать, а отправлять данные. Также в запрос можно добавить заголовки в виде объекта или специального класса `Headers`.
```js
const newPost = {
  title: 'foo',
  body: 'bar',
  userId: 1,
}

fetch('https://jsonplaceholder.typicode.com/posts', {
  method: 'POST', // Здесь так же могут быть GET, PUT, DELETE
  // Тело запроса в JSON-формате
  body: JSON.stringify(newPost),
  headers: {
    // Добавляем необходимые заголовки
    'Content-type': 'application/json; charset=UTF-8',
  },
})
  .then((response) => response.json())
  .then((data) => {
    console.log(data)
    // {title: "foo", body: "bar", userId: 1, id: 101}
  }
)
```

### Cookies

По умолчанию `fetch()` запросы не включают в себя cookies, и поэтому авторизованные запросы на сервере могут не пройти. Для этого необходимо добавить в настройку поле `credentials`:
```js
fetch('https://somesite.com/admin', {
  method: 'GET',
  // Или same-origin, если можно делать такие запросы
  // только в пределах этого домена
  credentials: 'include',
})
```

### Обработка ошибок

Любой ответ на запрос через `fetch()`, например, HTTP-код 400, 404 или 500, переводит `Promise` в состояние **fulfilled**. Промис перейдёт в состояние **rejected** только если запрос не случился из-за сбоя сети или что-то помешало выполнению `fetch()`.
```js
// Запрос вернёт ошибку «404 Not Found»
fetch('https://jsonplaceholder.typicode.com/there-is-no-such-route').catch(
  () => {
    console.log('Error occurred!')
  }
)
// Никогда не выполнится
```

Чтобы обработать ошибку запроса, необходимо обращать внимание на поле `ok` в объекте ответа `Response`. В случае ошибки запроса оно будет равно `false`.
```js
fetch('https://jsonplaceholder.typicode.com/there-is-no-such-route')
  .then((response) => {
    // Проверяем успешность запроса и выкидываем ошибку
    if (!response.ok) {
      throw new Error('Error occurred!')
    }

    return response.json()
  })
  // Теперь попадём сюда, так как выбросили ошибку
  .catch((err) => {
    console.log(err)
  }
)
// Error: Error occurred!
```

### Примеры с fetch

Вот пример использования функции `fetch` в JavaScript для выполнения HTTP-запроса и обработки ответа:

## 1) `Get`

```javascript
// Выполняем GET-запрос к API
fetch('https://jsonplaceholder.typicode.com/posts/1')
    .then(response => {
        // Проверяем, успешно ли выполнен запрос
        if (!response.ok) {
            throw new Error('Network response was not ok ' + response.statusText);
        }
        // Преобразуем ответ в JSON-формат
        return response.json();
    })
    .then(data => {
        // Обрабатываем данные из ответа
        console.log(data);
    })
    .catch(error => {
        // Обрабатываем ошибки
        console.error('There has been a problem with your fetch operation:', error);
    });
```

### Объяснение:
1. **fetch('https://jsonplaceholder.typicode.com/posts/1')** — Выполняет GET-запрос к указанному URL.
2. **response.ok** — Проверяет, успешно ли выполнен запрос (статус 200-299).
3. **response.json()** — Преобразует ответ в JSON.
4. **then(data => { ... })** — Получает данные в формате JSON и обрабатывает их.
5. **catch(error => { ... })** — Обрабатывает ошибки, возникшие во время выполнения запроса.


## 2) `Post`

```javascript
// Данные, которые мы отправляем на сервер
const postData = {
    title: 'foo',
    body: 'bar',
    userId: 1
};

// Выполняем POST-запрос к API
fetch('https://jsonplaceholder.typicode.com/posts', {
    method: 'POST', // Указываем метод запроса
    headers: {
        'Content-Type': 'application/json' // Указываем тип содержимого (JSON)
    },
    body: JSON.stringify(postData) // Преобразуем объект в JSON-строку для отправки
})
.then(response => {
    if (!response.ok) {
        throw new Error('Network response was not ok ' + response.statusText);
    }
    return response.json(); // Преобразуем ответ в JSON-формат
})
.then(data => {
    // Обрабатываем данные из ответа
    console.log('Success:', data);
})
.catch(error => {
    // Обрабатываем ошибки
    console.error('There has been a problem with your fetch operation:', error);
});
```

### Объяснение:
1. **method: 'POST'** — Указываем, что запрос должен использовать метод POST.
2. **headers: { 'Content-Type': 'application/json' }** — Устанавливаем заголовок `Content-Type`, чтобы сервер знал, что данные отправляются в формате JSON.
3. **body: JSON.stringify(postData)** — Преобразуем объект `postData` в строку JSON перед отправкой.
4. **response.json()** — Преобразует ответ сервера в объект JSON, чтобы можно было с ним работать.

В этом примере запрос отправляется на `https://jsonplaceholder.typicode.com/posts` с данными в теле запроса. Сервер в ответ возвращает созданный ресурс, который выводится в консоль.

## 3) `Get` **Async/Await**

Вот пример выполнения `GET`-запроса с использованием `async/await`:

```javascript
async function getDataFromServer(url) {
    try {
        // Выполняем GET-запрос
        const response = await fetch(url);

        // Проверяем, успешно ли выполнен запрос
        if (!response.ok) {
            throw new Error('Network response was not ok ' + response.statusText);
        }

        // Преобразуем ответ в JSON-формат
        const data = await response.json();
        console.log('Success:', data); // Обрабатываем данные из ответа
    } catch (error) {
        // Обрабатываем ошибки
        console.error('There has been a problem with your fetch operation:', error);
    }
}

// Вызов функции для получения данных
getDataFromServer('https://jsonplaceholder.typicode.com/posts/1');
```

### Объяснение:
1. **async function getDataFromServer(url)** — Определяем асинхронную функцию, которая принимает URL для получения данных.
2. **await fetch(url)** — Выполняем `fetch` с использованием `await` для выполнения GET-запроса. Код будет ждать завершения запроса перед продолжением выполнения.
3. **await response.json()** — Преобразуем ответ в JSON-формат с использованием `await`.
4. **try...catch** — Блок для обработки ошибок, позволяющий отловить любые ошибки, возникающие во время выполнения запроса.

Этот код делает запрос к указанному URL, ожидает ответа, проверяет успешность выполнения и преобразует данные в JSON перед тем, как вывести их в консоль.

## 4) `Post` **Async/Await**

```javascript
// Данные, которые мы отправляем на сервер
const postData = {
    title: 'foo',
    body: 'bar',
    userId: 1
};

async function postDataToServer(url = '', data = {}) {
    try {
        // Выполняем POST-запрос
        const response = await fetch(url, {
            method: 'POST', // Указываем метод запроса
            headers: {
                'Content-Type': 'application/json' // Указываем тип содержимого (JSON)
            },
            body: JSON.stringify(data) // Преобразуем объект в JSON-строку для отправки
        });

        // Проверяем, успешно ли выполнен запрос
        if (!response.ok) {
            throw new Error('Network response was not ok ' + response.statusText);
        }

        // Преобразуем ответ в JSON-формат
        const jsonData = await response.json();
        console.log('Success:', jsonData); // Обрабатываем данные из ответа
    } catch (error) {
        // Обрабатываем ошибки
        console.error('There has been a problem with your fetch operation:', error);
    }
}

// Вызов функции и отправка данных
postDataToServer('https://jsonplaceholder.typicode.com/posts', postData);
```

### Объяснение:
1. **async function postDataToServer(url = '', data = {})** — Определяем асинхронную функцию, которая принимает URL и данные для отправки.
2. **await fetch(url, { ... })** — Выполняем `fetch` с использованием `await`, что позволяет дождаться завершения запроса и продолжить выполнение кода после получения ответа.
3. **await response.json()** — Преобразуем ответ в JSON-формат с использованием `await`.
4. **try...catch** — Блок для обработки ошибок, возникающих во время выполнения запроса.

Асинхронный код с использованием `async/await` делает код более линейным и понятным, избегая вложенности `then` и `catch`.

[Оглавление - JavaScript 🔼](#menu)

<div id="56"></div>

## 56. `AbortController()`

`AbortController` — это встроенный объект в JavaScript, предназначенный для управления и отмены асинхронных операций, таких как HTTP-запросы, таймеры и другие долг-running задачи. Он особенно полезен в случаях, когда вы хотите отменить запросы или задачи, которые больше не нужны, например, при размонтировании компонента в React.

### Основные функции `AbortController`:

1. **Отмена запросов**: `AbortController` используется для отмены `fetch` запросов, если они больше не нужны, например, при размонтировании компонента в React.

2. **Сигналы**: `AbortController` создает сигнал (`AbortSignal`), который может быть передан в асинхронные операции. Когда сигнал отменяется, асинхронные операции могут реагировать на это и завершиться.

### Основные методы и свойства:

- **`AbortController`**: Конструктор для создания нового контроллера.
- **`signal`**: Свойство экземпляра `AbortController`, представляющее `AbortSignal`, который может быть передан в асинхронные операции.
- **`abort()`**: Метод для отмены всех операций, связанных с контроллером.

### Пример использования `AbortController` с `fetch`

Вот пример, который показывает, как использовать `AbortController` для отмены `fetch` запроса, если компонент размонтируется:

```javascript
import React, { useState, useEffect } from 'react';

function DataFetchingComponent() {
    const [data, setData] = useState(null);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState(null);

    useEffect(() => {
        const controller = new AbortController();
        const { signal } = controller;

        // Выполняем GET-запрос
        fetch('https://jsonplaceholder.typicode.com/posts/1', { signal })
            .then(response => {
                if (!response.ok) {
                    throw new Error('Network response was not ok ' + response.statusText);
                }
                return response.json();
            })
            .then(data => {
                setData(data);
                setLoading(false);
            })
            .catch(error => {
                if (error.name === 'AbortError') {
                    console.log('Fetch aborted');
                } else {
                    setError(error);
                    setLoading(false);
                }
            });

        // Функция очистки, которая отменяет запрос при размонтировании компонента
        return () => {
            controller.abort();
        };
    }, []); // Пустой массив зависимостей означает, что эффект будет выполнен один раз при монтировании

    if (loading) return <div>Loading...</div>;
    if (error) return <div>Error: {error.message}</div>;

    return (
        <div>
            <h1>{data.title}</h1>
            <p>{data.body}</p>
        </div>
    );
}

export default DataFetchingComponent;
```

### Как это работает:
1. **Создание контроллера**: В `useEffect` создается новый экземпляр `AbortController`.

2. **Получение сигнала**: Свойство `signal` из контроллера передается в `fetch` запрос, чтобы привязать запрос к этому сигналу.

3. **Отмена запроса**: Когда компонент размонтируется, функция очистки, возвращаемая из `useEffect`, вызывает метод `abort()` на контроллере. Это сигнализирует `fetch`, что запрос должен быть отменен.

4. **Обработка отмены**: В блоке `catch` проверяется, была ли ошибка вызвана отменой запроса (`error.name === 'AbortError'`). Это позволяет отличать отмену запроса от других типов ошибок.

### Другие применения:

- **Отмена таймеров**: Вы можете использовать `AbortController` для отмены таймеров или других асинхронных задач, хотя для таймеров это не столь распространено.

- **Подписки**: В случае подписки на события, вы можете использовать `AbortController` для управления и отмены подписок.

`AbortController` предоставляет удобный способ управления долг-running задачами и отмены их выполнения в нужный момент, что помогает избегать утечек памяти и улучшает производительность приложений.

[Оглавление - JavaScript 🔼](#menu)

<div id="57"></div>

## 57. Какие есть способы для работы с запросами в React?

В React существует несколько способов работы с HTTP-запросами. Они различаются по сложности, возможностям и экосистеме. Вот основные подходы:

### 1. **Использование встроенного `fetch()` API**

Это наиболее базовый способ выполнения HTTP-запросов в React. `fetch()` — это встроенный в браузер API, который позволяет выполнять асинхронные запросы. Этот подход не требует сторонних библиотек и подходит для простых случаев.

**Пример использования `fetch` в `useEffect`:**

```javascript
import React, { useState, useEffect } from 'react';

function DataFetchingComponent() {
    const [data, setData] = useState(null);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState(null);

    useEffect(() => {
        fetch('https://jsonplaceholder.typicode.com/posts/1')
            .then(response => {
                if (!response.ok) {
                    throw new Error('Network response was not ok');
                }
                return response.json();
            })
            .then(data => {
                setData(data);
                setLoading(false);
            })
            .catch(error => {
                setError(error);
                setLoading(false);
            });
    }, []);

    if (loading) return <div>Loading...</div>;
    if (error) return <div>Error: {error.message}</div>;

    return (
        <div>
            <h1>{data.title}</h1>
            <p>{data.body}</p>
        </div>
    );
}

export default DataFetchingComponent;
```

### 2. **Использование сторонней библиотеки `Axios`**

`Axios` — это популярная библиотека для выполнения HTTP-запросов, которая предлагает более удобный API по сравнению с `fetch()`. Она поддерживает такие функции, как обработка таймаутов, перехватчики запросов и ответов, автоматическое преобразование JSON и многое другое.

**Пример использования `Axios`:**

```javascript
import React, { useState, useEffect } from 'react';
import axios from 'axios';

function DataFetchingComponent() {
    const [data, setData] = useState(null);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState(null);

    useEffect(() => {
        axios.get('https://jsonplaceholder.typicode.com/posts/1')
            .then(response => {
                setData(response.data);
                setLoading(false);
            })
            .catch(error => {
                setError(error);
                setLoading(false);
            });
    }, []);

    if (loading) return <div>Loading...</div>;
    if (error) return <div>Error: {error.message}</div>;

    return (
        <div>
            <h1>{data.title}</h1>
            <p>{data.body}</p>
        </div>
    );
}

export default DataFetchingComponent;
```

### 3. **Использование `React Query` (или аналогичных библиотек)**

`React Query` — это мощная библиотека для управления состоянием и кэшированием данных, полученных из API. Она автоматически обновляет данные, поддерживает поллинги, управление состоянием загрузки и ошибок, а также повторные запросы в случае ошибки.

**Пример использования `React Query`:**

```javascript
import React from 'react';
import { useQuery } from 'react-query';
import axios from 'axios';

function DataFetchingComponent() {
    const { data, error, isLoading } = useQuery('post', () =>
        axios.get('https://jsonplaceholder.typicode.com/posts/1').then(res => res.data)
    );

    if (isLoading) return <div>Loading...</div>;
    if (error) return <div>Error: {error.message}</div>;

    return (
        <div>
            <h1>{data.title}</h1>
            <p>{data.body}</p>
        </div>
    );
}

export default DataFetchingComponent;
```

### 4. **Использование `SWR`**

`SWR` — это еще одна библиотека, разработанная Vercel. Она предоставляет удобный интерфейс для извлечения, кэширования и синхронизации данных из API. Она похожа на `React Query`, но более минималистична.

**Пример использования `SWR`:**

```javascript
import React from 'react';
import useSWR from 'swr';
import axios from 'axios';

const fetcher = url => axios.get(url).then(res => res.data);

function DataFetchingComponent() {
    const { data, error } = useSWR('https://jsonplaceholder.typicode.com/posts/1', fetcher);

    if (!data) return <div>Loading...</div>;
    if (error) return <div>Error: {error.message}</div>;

    return (
        <div>
            <h1>{data.title}</h1>
            <p>{data.body}</p>
        </div>
    );
}

export default DataFetchingComponent;
```

### 5. **Использование кастомных хуков**

Кастомные хуки позволяют инкапсулировать логику работы с API в повторно используемый компонент. Это удобно для разделения кода и повторного использования запросов в различных компонентах.

**Пример кастомного хука для `fetch`:**

```javascript
import { useState, useEffect } from 'react';

function useFetch(url) {
    const [data, setData] = useState(null);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState(null);

    useEffect(() => {
        fetch(url)
            .then(response => {
                if (!response.ok) {
                    throw new Error('Network response was not ok');
                }
                return response.json();
            })
            .then(data => {
                setData(data);
                setLoading(false);
            })
            .catch(error => {
                setError(error);
                setLoading(false);
            });
    }, [url]);

    return { data, loading, error };
}

// Использование кастомного хука
function DataFetchingComponent() {
    const { data, loading, error } = useFetch('https://jsonplaceholder.typicode.com/posts/1');

    if (loading) return <div>Loading...</div>;
    if (error) return <div>Error: {error.message}</div>;

    return (
        <div>
            <h1>{data.title}</h1>
            <p>{data.body}</p>
        </div>
    );
}

export default DataFetchingComponent;
```

### 6. **Использование GraphQL (Apollo Client, Relay)**

Для приложений, использующих GraphQL, вы можете использовать `Apollo Client` или `Relay`. Эти библиотеки предоставляют мощные инструменты для работы с запросами, мутациями и подписками.

**Пример использования `Apollo Client` с GraphQL:**

```javascript
import React from 'react';
import { useQuery, gql } from '@apollo/client';

const GET_POST = gql`
    query GetPost($id: ID!) {
        post(id: $id) {
            title
            body
        }
    }
`;

function DataFetchingComponent() {
    const { loading, error, data } = useQuery(GET_POST, { variables: { id: 1 } });

    if (loading) return <div>Loading...</div>;
    if (error) return <div>Error: {error.message}</div>;

    return (
        <div>
            <h1>{data.post.title}</h1>
            <p>{data.post.body}</p>
        </div>
    );
}

export default DataFetchingComponent;
```

### Резюме:

- **`fetch()`**: Простое и встроенное решение, но требует больше кода для обработки ошибок и данных.
- **`Axios`**: Библиотека с удобным API и дополнительными функциями.
- **`React Query` и `SWR`**: Современные решения для управления данными с широкими возможностями кэширования и управления состоянием.
- **Кастомные хуки**: Позволяют повторно использовать логику запросов в разных компонентах.
- **GraphQL (Apollo, Relay)**: Специализированные библиотеки для работы с GraphQL.

Выбор подхода зависит от сложности вашего проекта и предпочтений команды.

[Оглавление - JavaScript 🔼](#menu)

<div id="58"></div>

## 58. Как сервер может запретить чтение cookie из браузера? **(флаг HttpOnly)**

**Подробнее –** [HttpOnly](https://learn.javascript.ru/cookie%23httponly)

С помощью флага HttpOnly сервер может запретить любой доступ к куки из JavaScript. Мы не можем видеть такое куки или манипулировать им с помощью document.cookie.

Эта настройка используется в качестве меры предосторожности от определённых атак, когда хакер внедряет свой собственный JavaScript-код в страницу и ждёт, когда пользователь посетит её. Это вообще не должно быть возможным, хакер не должен быть в состоянии внедрить свой код на ваш сайт, но могут быть ошибки, которые позволят хакеру сделать это.

[Оглавление - JavaScript 🔼](#menu)

## Массивы и строки

<div id="59"></div>

## 59. методы массивов в JavaScript

1.  **push()** - добавляет один или несколько элементов в конец массива и возвращает новую длину массива.
```js
let arr = [1, 2, 3];
arr.push(4); // Вернет 4
// arr теперь равен [1, 2, 3, 4]
```
2.  **pop()** - удаляет последний элемент из массива и возвращает его.
```js
let arr = [1, 2, 3];
let last = arr.pop(); // Вернет 3
// arr теперь равен [1, 2]
```
3.  **shift()** - удаляет первый элемент из массива и возвращает его.
```js
let arr = [1, 2, 3];
let first = arr.shift(); // Вернет 1
// arr теперь равен [2, 3]
```
4.  **unshift()** - добавляет один или несколько элементов в начало массива и возвращает новую длину массива.
```js
let arr = [1, 2, 3];
arr.unshift(0); // Вернет 4
// arr теперь равен [0, 1, 2, 3]
```
5.  **slice()** - возвращает новый массив, содержащий копию части исходного массива.
```js
let arr = [1, 2, 3, 4, 5];
let sliced = arr.slice(1, 4); // Вернет [2, 3, 4]
// arr остается без изменений
```
6.  **splice()** - изменяет исходный массив, удаляя, заменяя или добавляя элементы.
```js
let arr = [1, 2, 3, 4, 5];
arr.splice(1, 2, 'two', 'three'); // Вернет [2, 3]
// arr теперь равен [1, 'two', 'three', 4, 5]
```
7.  **map()** - создает новый массив, содержащий результаты вызова указанной функции для каждого элемента исходного массива.
```js
let arr = [1, 2, 3];
let doubled = arr.map(num => num * 2); // Вернет [2, 4, 6]
// arr остается без изменений
```
8.  **filter()** - создает новый массив с элементами, которые проходят тест, заданный в переданной функции.
```js
let arr = [1, 2, 3, 4, 5];
let even = arr.filter(num => num % 2 === 0); // Вернет [2, 4]
// arr остается без изменений
```
9.  **reduce()** - применяет функцию к каждому элементу массива (слева направо), чтобы свести его к одному значению.
```js
let arr = [1, 2, 3, 4, 5];
let sum = arr.reduce((total, num) => total + num, 0); // Вернет 15
// arr остается без изменений
```
10.  **forEach()** - выполняет указанную функцию один раз для каждого элемента массива.
```js
let arr = [1, 2, 3];
arr.forEach(num => console.log(num));
// Выведет 1, затем 2, затем 3
```
11.  **includes()** - проверяет, содержит ли массив указанный элемент, возвращая true или false.
```js
let arr = [1, 2, 3];
let includesTwo = arr.includes(2); // Вернет true
```
12.  **find()** - возвращает первый элемент в массиве, который удовлетворяет предоставленной функции тестирования. Если такой элемент не найден, вернет undefined.
```js
let arr = [1, 2, 3, 4, 5];
let found = arr.find(num => num > 3); // Вернет 4
```
13.  **findIndex()** - возвращает индекс первого элемента в массиве, который удовлетворяет предоставленной функции тестирования. В противном случае возвращает -1.
```js
let arr = [1, 2, 3, 4, 5];
let foundIndex = arr.findIndex(num => num > 3); // Вернет 3
```
14.  **some()** - проверяет, удовлетворяет ли хотя бы один элемент массива условию, заданному в передаваемой функции.
```js
let arr = [1, 2, 3, 4, 5];
let hasEvenNumber = arr.some(num => num % 2 === 0); // Вернет true
```
15.  **every()** - проверяет, удовлетворяют ли все элементы массива условию, заданному в передаваемой функции.
```js
let arr = [1, 2, 3, 4, 5];
let areAllNumbersPositive = arr.every(num => num > 0); // Вернет true
```
16.  **concat()** - используется для объединения двух или более массивов.
```js
let arr1 = [1, 2, 3];
let arr2 = [4, 5, 6];
let merged = arr1.concat(arr2); // Вернет [1, 2, 3, 4, 5, 6]
```

[Оглавление - JavaScript 🔼](#menu)

<div id="60"></div>

## 60. методы строк в JavaScript

1.  **charAt(index)**: Возвращает символ на определенном индексе.
```js
let str = 'Hello, world!';
console.log(str.charAt(0));  // 'H'
```
2.  **concat(string2, string3, ..., stringX)**: Соединяет две или более строк и возвращает новую строку.
```js
let str1 = 'Hello, ';
let str2 = 'world!';
console.log(str1.concat(str2));  // 'Hello, world!'
```
3.  **includes(searchValue, start)**: Определяет, содержит ли строка указанное значение.
```js
let str = 'Hello, world!';
console.log(str.includes('world'));  // true
```
4.  **indexOf(searchValue, start)**: Возвращает индекс первого вхождения указанного текста.
```js
let str = 'Hello, world!';
console.log(str.indexOf('world'));  // 7
```
5.  **lastIndexOf(searchValue, start)**: Возвращает последний индекс вхождения указанного текста.
```js
let str = 'Hello, world, world!';
console.log(str.lastIndexOf('world'));  // 14
```
6.  **replace(searchFor, replaceWith)**: Заменяет указанный текст на другой.
```js
let str = 'Hello, world!';
console.log(str.replace('world', 'JavaScript'));  // 'Hello, JavaScript!'
```
7.  **slice(start, end)**: Извлекает часть строки и возвращает ее как новую строку.
```js
let str = 'Hello, world!';
console.log(str.slice(7, 12));  // 'world'
```
8.  **split(separator, limit)**: Разбивает строку на массив подстрок.
```js
let str = 'Hello, world!';
console.log(str.split(' '));  // ['Hello,', 'world!']
```
9.  **startsWith(searchValue, start)**: Определяет, начинается ли строка с указанных символов.
```js
let str = 'Hello, world!';
console.log(str.startsWith('Hello'));  // true
```
10.  **substring(indexStart, indexEnd)**: Возвращает новую строку, содержащую символы строки, извлеченные между двумя указанными индексами.
```js
let str = 'Hello, world!';
console.log(str.substring(7, 12));  // 'world'
```
11.  **toLowerCase()**: Конвертирует строку в нижний регистр.
```js
 let str = 'HELLO, WORLD!';
console.log(str.toLowerCase());  // 'hello, world!'
```
12.  **toUpperCase()**: Конвертирует строку в верхний регистр.
```js
let str = 'Hello, world!';
console.log(str.toUpperCase());  // 'HELLO, WORLD!'
```
13.  **trim()**: Удаляет пробелы с обеих концов строки.
```js
let str = '   Hello, world!   ';
console.log(str.trim());  // 'Hello, world!'
```
14.  **trimStart() / trimLeft()**: Удаляет пробелы с начала строки.
```js
let str = '   Hello, world!   ';
console.log(str.trimStart());  // 'Hello, world!   '
```
15.  **trimEnd() / trimRight()**: Удаляет пробелы с конца строки.
```js
let str = '   Hello, world!   ';
console.log(str.trimEnd());  // '   Hello, world!'
```
16.  **repeat(count)**: Конструирует и возвращает новую строку, которая содержит указанное количество копий строки, на которой был вызван метод.
```js
let str = 'Ha';
console.log(str.repeat(5));  // 'HaHaHaHaHa'
```
17.  **match(regexp)**: Ищет совпадение с регулярным выражением в строке.
```js
let str = 'Hello, world!';
let result = str.match(/o/g);  // вернет массив ['o', 'o']
```
18.  **search(regexp)**: Ищет совпадение с регулярным выражением в строке и возвращает позицию совпадения.
```js
let str = 'Hello, world!';
console.log(str.search(/o/));  // 4
```

[Оглавление - JavaScript 🔼](#menu)

<div id="61"></div>

## 61. Как проверить, является ли объект массивом? `Array.isArray(arr)`

Для этого предназначен специальный метод, возвращающий true или false Array.isArray().

```js
let arr = [1, 2, 3];
console.log(Array.isArray(arr)); // Вывод: true

let obj = {a: 1, b: 2};
console.log(Array.isArray(obj)); // Вывод: false
```

[Оглавление - JavaScript 🔼](#menu)

## Локальное хранение данных

<div id="62"></div>

## 62. Какие способы хранения данных в браузере вы знаете?

**Подробнее –** [LocalStorage, sessionStorage](https://learn.javascript.ru/localstorage)
**Подробнее -** [Cookies](https://learn.javascript.ru/cookie)
**Подробнее -** [IndexedDB](https://learn.javascript.ru/indexeddb)

Существует несколько подходов к хранению данных в браузере:

1. **LocalStorage, SessionStorage** - позволяют хранить пары ключ/значение в браузере.
Это API веб-хранилища, которое позволяет веб-сайтам хранить большие объемы данных (до 5-10 МБ в зависимости от браузера) в браузере пользователя.
	- **LocalStorage** - Данные, сохраненные через LocalStorage, не имеют срока истечения и сохраняются, даже если браузер закрыт или перезагружен.
	- **SessionStorage** - Данные в SessionStorage сохраняются только в течение сессии браузера. Как только вкладка или браузер закрываются, данные удаляются.

Объекты хранилища **localStorage** и **sessionStorage** предоставляют одинаковые методы и свойства:

- setItem(key, value) – сохранить пару ключ/значение.
- getItem(key) – получить данные по ключу key.
- removeItem(key) – удалить данные с ключом key.
- clear() – удалить всё.
- key(index) – получить ключ на заданной позиции.
- length – количество элементов в хранилище.


Оба хранилища в качестве ключей и значений могут использовать только строки, поэтому объекты не забываем преобразовывать с помощью JSON.stringify.

**LocalStorage** и **SessionStorage** хорошо подходят для хранения больших объемов данных, которые не требуются на сервере и которые необходимо сохранить между сессиями (LocalStorage) или только в течение текущей сессии (SessionStorage).

---

2. **Cookies** – это небольшие строки данных, которые хранятся непосредственно в браузере. Куки обычно устанавливаются веб-сервером при помощи заголовка Set-Cookie. Затем браузер будет автоматически добавлять их в (почти) каждый запрос на тот же домен при помощи заголовка Cookie. одно куки вмещает до 4kb данных, разрешается более 20 куки на сайт (зависит от браузера).

**Cookies** могут быть полезными для хранения небольших объемов данных, которые должны быть доступны на сервере, таких как идентификаторы сессий или токены аутентификации.

---

3. **IndexedDB** – это встроенная база данных, более мощная, чем localStorage.

- Хранилище ключей/значений: доступны несколько типов ключей, а значения могут быть (почти) любыми.
- Поддерживает транзакции для надёжности.
- Поддерживает запросы в диапазоне ключей и индексы.
- Позволяет хранить больше данных, чем localStorage.

Для традиционных клиент-серверных приложений эта мощность обычно чрезмерна. IndexedDB предназначена для оффлайн приложений, можно совмещать с ServiceWorkers и другими технологиями.

**IndexedDB** может быть полезной для хранения очень больших объемов структурированных данных в браузере, которые можно эффективно обрабатывать и извлекать.

---

Важно❗️ надо помнить о вопросах безопасности и конфиденциальности при хранении данных в браузере. Хотя эти методы хранения данных могут быть защищены от доступа из других веб-сайтов, вредоносный код, работающий на том же веб-сайте, может получить доступ к этим данным. Кроме того, пользователи могут вручную очистить все эти данные, поэтому они не должны использоваться как единственный способ хранения важной или чувствительной информации.

[Оглавление - JavaScript 🔼](#menu)

<div id="63"></div>

## 63. В чем отличие sessionStorage от localStorage?

SessionStorage и LocalStorage — это два объекта веб-хранилища, доступные в браузерах, которые позволяют вам сохранять данные в пользовательском браузере. Они оба предлагают одинаковый API для работы с данными, но есть важные различия в их поведении и сфере применения.

**SessionStorage** сохраняет данные только для одной сессии браузера. Данные, сохраненные в SessionStorage, удаляются, как только пользователь закрывает вкладку или окно браузера, в котором была открыта сессия. Это делает SessionStorage полезным для хранения временных данных, таких как информация для одной сессии интернет-магазина.

**LocalStorage**, с другой стороны, сохраняет данные без истечения срока действия. Данные, сохраненные в LocalStorage, остаются в браузере даже после его закрытия и перезапуска. Это делает LocalStorage полезным для хранения данных, которые должны оставаться между различными сессиями браузера, таких как предпочтения пользователя на веб-сайте.

Важно отметить, что и SessionStorage, и LocalStorage являются специфичными для источника, то есть данные, сохраненные веб-сайтом в SessionStorage или LocalStorage, доступны только этому веб-сайту и не могут быть прочитаны или изменены другими веб-сайтами.

[Оглавление - JavaScript 🔼](#menu)

## Разное

<div id="7"></div>

## 7. Что такое замыкание?

**Подробнее -** [Замыкание](https://learn.javascript.ru/closure)

**Замыкание** – это способность функции "запомнить" и получить доступ к переменным из родительской области видимости, даже после того, как родительская функция перестала выполняться. Замыкания создаются каждый раз, когда функция создается.

```js
function createAdder(x) {
  return function(y) {
    return x + y;
  };
}

const add5 = createAdder(5);
console.log(add5(2));  // 7
```
В этом примере функция `createAdder` возвращает новую функцию, которая "запоминает" значение `x`. Даже когда `createAdder` завершила свое выполнение, возвращаемая функция все еще имеет доступ к `x`. Это возможно благодаря замыканию.

Замыкания в JavaScript могут быть использованы для различных целей, включая создание фабрик функций, инкапсуляцию данных и управление асинхронным кодом.

[Оглавление - JavaScript 🔼](#menu)

<div id="8"></div>

## 8. Что такое шаблонные литералы и для чего они нужные?

**Подробнее -** [Шаблонные литералы](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Template_literals)

Шаблонные литералы - косые кавычки, в которых возможен перенос строки и в них также можно встраивать выражения.

```js
let b = 5;
const a = `Сумма равна ${b}`;
```

В общем, шаблонные литералы делают работу со строками в JavaScript более удобной и гибкой.

[Оглавление - JavaScript 🔼](#menu)









<div id="16"></div>

## 16. Как избежать ссылочной зависимости при копировании объекта? Поверхстное и глубокое копирование объекта

**Подробнее -** [Глубокое копирование](https://www.youtube.com/watch?v=iDTZKdfJEcw&ab_channel=UlbiTV)

### Поверхстное копирование

**Если объект не содержит внутренних объектов, например:**
```js
const obj = {
	key: ‘value’,
	field: 1
}

// В таком случае можно воспользоваться стандартными приемами:
1. const copy = {...obj} // спред оператором
// или
2. const copy = Object.assign({}, obj}
```
**Если объект СОДЕРЖИТ внутренние объекты:**
```js
const obj = {
	key: {
		field: 1
	}
}
```

В таком случае необходимо делать глубокое копирование:

### Глубокое копирование

1. Глобальная функция structuredClone()

пример использования:

```js
// Create an object with a value and a circular reference to itself.
const original = { name: "MDN" };
original.itself = original;

// Clone it
const clone = structuredClone(original);

console.assert(clone !== original); // the objects are not the same (not same identity)
console.assert(clone.name === "MDN"); // they do have the same values
console.assert(clone.itself === clone); // and the circular reference is preserved
```

2. JSON.parse и JSON.stringify
Самый простой способ глубокого копирования - это использовать методы `JSON.stringify` и `JSON.parse`. Метод `JSON.stringify` преобразует объект в строку JSON, а затем `JSON.parse` преобразует эту строку обратно в новый объект:

```js
let original = { a: 1, b: { c: 2 } };
let copy = JSON.parse(JSON.stringify(original));
```
Этот метод очень прост, но у него есть некоторые ограничения. Он не может копировать функции или циклические ссылки, и он может иметь проблемы с некоторыми другими типами данных, такими как Date, RegExp, Map, Set и т.д.

3. Использование библиотек
Существуют различные библиотеки, которые предоставляют функции для глубокого копирования, например, Lodash (`_.cloneDeep`) и jQuery (`$.extend(true, {}, obj)`). Эти функции обычно гораздо мощнее и гибче, чем простое использование `JSON.parse` и `JSON.stringify`, и могут справиться с большим количеством типов данных и ситуаций.

4. Рекурсивное копирование
заключается в том, чтобы обойти все свойства объекта и рекурсивно копировать их. Этот подход может быть настроен под конкретные требования и может обрабатывать циклические ссылки, но он требует больше кода и может быть сложнее в поддержке.
```js
function deepCopy(obj) {
    let copy;

    // обрабатываем 3 простых типа и null или undefined
    if (null == obj || "object" != typeof obj) return obj;

    // обрабатываем Array
    if (obj instanceof Array) {
        copy = [];
        for (let i = 0, len = obj.length; i < len; i++) {
            copy[i] = deepCopy(obj[i]);
        }
        return copy;
    }

    // обрабатываем Object
    if (obj instanceof Object) {
        copy = {};
        for (let attr in obj) {
            if (obj.hasOwnProperty(attr)) copy[attr] = deepCopy(obj[attr]);
        }
        return copy;
    }

    throw new Error("Unable to copy obj! Its type isn't supported.");
}

// Пример использования:
let original = { a: 1, b: { c: 2 } };
let copy = deepCopy(original);
console.log(copy);  // { a: 1, b: { c: 2 } }

```
**4. Использование структур данных ES6**

Если вы работаете только с некоторыми типами данных ES6, такими как Map и Set, они имеют методы для создания копий, которые можно использовать для глубокого копирования. Однако, вам все равно может потребоваться комбинировать это с другими методами для полного глубокого копирования.

В общем, наиболее подходящий метод глубокого копирования зависит от конкретных требований вашего проекта и данных, с которыми вы работаете.

[Оглавление - JavaScript 🔼](#menu)

<div id="17"></div>

## 17. Как работает ключевое слово this?

В JavaScript, ключевое слово `this` является контекстом и обычно относится к объекту, в контексте которого вызывается функция. Однако, его значение может варьироваться в зависимости от того, как и где вызывается функция.

**1. В глобальном контексте**

В глобальном контексте (вне любой функции) `this` относится к глобальному объекту. В браузере глобальный объект - это `window`.
```js
console.log(this === window); // true
```

**2. Внутри функции**

В обычной функции (не стрелочной функции) `this` внутри функции зависит от того, как эта функция вызывается.
```js
function test() {
    console.log(this);
}

test(); // window (в браузере)

const obj = {
    method: test
};

obj.method(); // obj
```

**3. Внутри метода**

Внутри метода объекта `this` обычно относится к объекту, которому принадлежит метод.
```js
const obj = {
    prop: 42,
    method: function() {
        console.log(this.prop);
    }
};

obj.method(); // 42
```
**4. Внутри конструктора**

Внутри функции-конструктора `this` относится к новосозданному объекту.
```js
function Test() {
    this.prop = 42;
}

const obj = new Test();

console.log(obj.prop); // 42
```
**5. Внутри стрелочной функции**

Стрелочные функции не имеют собственного `this`. Внутри стрелочной функции `this` ссылается на значение `this` из окружающего лексического контекста.

```js
const obj = {
    prop: 42,
    method: function() {
        const arrowFunc = () => console.log(this.prop);
        arrowFunc();
    }
};

obj.method(); // 42
```
**6. При использовании call, apply, bind**

Методы `call()`, `apply()` и `bind()` позволяют явно задать значение `this`.
```js
function test() {
    console.log(this);
}

const obj = {};

test.call(obj); // obj
```

---
В глобальном контексте выполнения (за пределами каких-либо функций), this ссылается на глобальный объект вне зависимости от использования в строгом или нестрогом режиме.

В пределах функции значение this зависит от того, каким образом вызвана функция:

- Простой вызов - В этом случае значение this не устанавливается вызовом. Так как этот код написан не в строгом режиме, значением this всегда должен быть объект, по умолчанию - глобальный объект. В строгом режиме, значение this остается тем значением, которое было установлено в контексте исполнения. Если такое значение не определено, оно остается undefined. Для того что бы передать значение this от одного контекста другому необходимо использовать call или apply
- В стрелочных функциях, this привязан к окружению, в котором была создана функция. В глобальной области видимости, this будет указывать на глобальный объект.
- Когда функция вызывается как метод объекта, используемое в этой функции ключевое слово this принимает значение объекта, по отношению к которому вызван метод.

Контекст, - не скоуп!!!

Контекст выполнения это концепция, описывающая окружение, в котором производится выполнение кода на JavaScript. Код всегда выполняется внутри некоего контекста.

this ссылается на значение объекта, который в данный момент выполняет или вызывает функцию.

При наличии функций, программа обладает несколькими уровнями, а ключевое слово this указывает на то, где вы находитесь, и какой именно объект является функцией.

[Оглавление - JavaScript 🔼](#menu)

<div id="18"></div>

## 18. Как поменять контекст функции? `call`, `bind`, `apply`

**Подробнее -** [call, bind, apply](https://learn.javascript.ru/call-apply-decorators)


В JavaScript существуют три основных способа изменить контекст (`this`) функции: `call()`, `apply()` и `bind()`.

**1. Метод call()**

Метод `call()` позволяет вызвать функцию, явно указывая ей контекст `this`. Первый аргумент `call()` - это значение, которое должно быть присвоено `this`. Остальные аргументы - это аргументы, которые будут переданы в вызываемую функцию.
```js
function greet() {
    console.log(`Hello, my name is ${this.name}`);
}

const person = { name: 'Alice' };
greet.call(person); // Выведет: "Hello, my name is Alice"
```
**2. Метод apply()**

Метод `apply()` очень похож на `call()`, но принимает аргументы в виде массива или объекта, подобного массиву.
```js
function greet(lang1, lang2) {
    console.log(`Hello, my name is ${this.name} and I speak ${lang1} and ${lang2}`);
}

const person = { name: 'Alice' };
greet.apply(person, ['English', 'French']);
// Выведет: "Hello, my name is Alice and I speak English and French"
```
**3. Метод bind()**

Метод `bind()` создает новую функцию, которая при вызове будет иметь указанный контекст `this`. Первый аргумент `bind()` - это значение, которое должно быть присвоено `this`.
```js
function greet() {
    console.log(`Hello, my name is ${this.name}`);
}

const person = { name: 'Alice' };
const greetPerson = greet.bind(person);
greetPerson();  // Выведет: "Hello, my name is Alice"
```

Метод `bind()` полезен, когда вы хотите создать функцию, которую можно вызвать позже, но с определенным контекстом `this`.

Все эти методы позволяют изменить контекст функции, но они используются в разных ситуациях и по-разному влияют на функцию.

[Оглавление - JavaScript 🔼](#menu)


<div id="24"></div>

## 24. Что такое DOM дерево?

**Подробнее -** [DOM](https://learn.javascript.ru/dom-nodes)

---

Основой HTML-документа являются теги.

В соответствии с объектной моделью документа DOM (Document Object Model), Каждый HTML-тег является объектом.

Вложенные теги являются «детьми» родительского элемента.

Текст, который находится внутри тега, также является объектом.

Все эти объекты доступны при помощи JavaScript, мы можем использовать их для изменения страницы.

---
DOM дерево состоит из объектов, называемых "узлами", которые представляют различные части веб-страницы: элементы, атрибуты, текст и так далее. Все эти узлы организованы в иерархическую структуру, которая отражает структуру HTML-кода страницы.

Вершина этого дерева - объект `document`, который представляет весь HTML-документ. От него идут ветви к дочерним узлам, таким как `html`, `head`, `body` и так далее. Эти узлы, в свою очередь, могут иметь своих дочерних узлов, представляющих более мелкие элементы на странице, и так далее, формируя иерархическую структуру дерева.

DOM – это представление HTML-документа в виде дерева тегов:
- HTML:
```html
<!DOCTYPE html>
<html>
  <head>
    <title>Пример</title>
  </head>
  <body>
    <h1>Привет, мир!</h1>
    <p>Добро пожаловать на мою веб-страницу</p>
  </body>
</html>
```
- DOM-дерево:
```js
document
 ├── html
 │   ├── head
 │   │   └── title
 │   │       └── "Пример"
 │   └── body
 │       ├── h1
 │       │   └── "Привет, мир!"
 │       └── p
 │           └── "Добро пожаловать на мою веб-страницу"
 └── DOCTYPE: html
```

[Оглавление - JavaScript 🔼](#menu)





[Оглавление - JavaScript 🔼](#menu)

<div id="30"></div>

## 30. Shadow DOM

**Подробнее -** [Shadow DOM](https://learn.javascript.ru/shadow-dom)

Теневой DOM («Shadow DOM») используется для инкапсуляции. Благодаря ему в компоненте есть собственное «теневое» DOM-дерево, к которому нельзя просто так обратиться из главного документа, у него могут быть изолированные CSS-правила и т.д.

Она (теневая модель) является частью документа и встраивается непосредственно внутрь страницы.

Теневой DOM – это способ создать свой, изолированный, DOM для компонента.
1. `shadowRoot = elem.attachShadow({mode: open})` – создаёт теневой DOM для elem. Если mode="open", он доступен через свойство elem.shadowRoot.
2. Мы можем создать подэлементы внутри shadowRoot с помощью innerHTMLили других методов DOM.

[Оглавление - JavaScript 🔼](#menu)



<div id="32"></div>

## 32. Что такое Полифилы?

**Подробнее –** [Полифилы](https://learn.javascript.ru/polyfills)

«Полифил» – это библиотека, которая добавляет в старые браузеры поддержку возможностей, которые в современных браузерах являются встроенными

---

- [Babel](https://learn.javascript.ru/polyfills#babel)

Когда мы используем современные возможности JavaScript, некоторые движки могут не поддерживать их. Как было сказано выше, не везде реализованы все функции.

И тут приходит на помощь Babel.

[Babel](https://babeljs.io/)  – это  [транспилер](https://ru.wikipedia.org/wiki/%D0%A2%D1%80%D0%B0%D0%BD%D1%81%D0%BF%D0%B0%D0%B9%D0%BB%D0%B5%D1%80). Он переписывает современный JavaScript-код в предыдущий стандарт.

На самом деле, есть две части Babel:

1.  Во-первых, транспилер, который переписывает код. Разработчик запускает Babel на своём компьютере. Он переписывает код в старый стандарт. И после этого код отправляется на сайт. Современные сборщики проектов, такие как  [webpack](http://webpack.github.io/)  или  [brunch](https://brunch.io/), предоставляют возможность запускать транспилер автоматически после каждого изменения кода, что позволяет экономить время.
2.  Во-вторых, полифил.
    Новые возможности языка могут включать встроенные функции и синтаксические конструкции. Транспилер переписывает код, преобразовывая новые синтаксические конструкции в старые. Но что касается новых встроенных функций, нам нужно их как-то реализовать. JavaScript является высокодинамичным языком, скрипты могут добавлять/изменять любые функции, чтобы они вели себя в соответствии с современным стандартом.

   - Термин «полифил» означает, что скрипт «заполняет» пробелы и добавляет современные функции.

   Два интересных хранилища полифилов:
    -   [core js](https://github.com/zloirock/core-js)  поддерживает много функций, можно подключать только нужные.
    -   [polyfill.io](https://polyfill.io/)  – сервис, который автоматически создаёт скрипт с полифилом в зависимости от необходимых функций и браузера пользователя.

Таким образом, чтобы современные функции поддерживались в старых движках, нам надо установить транспилер и добавить полифил.

[Оглавление - JavaScript 🔼](#menu)

<div id="33"></div>

## 33. Что такое - функция конструктор?

**Подробнее -** [Функция конструктор](https://learn.javascript.ru/constructor-new)

Функции-конструкторы являются обычными функциями. Но есть два соглашения:

1. Имя функции-конструктора должно начинаться с большой буквы.
2. Функция-конструктор должна вызываться при помощи оператора "new".
```js
function Car(make, model, year) {
  this.make = make;
  this.model = model;
  this.year = year;
}

let myCar = new Car('Toyota', 'Corolla', 2005);
```
Когда функция вызывается как new Car(...), происходит следующее:
-   Создаётся новый пустой объект, и он присваивается this.
-   Выполняется код функции. Обычно он модифицирует this, добавляет туда новые свойства.
-   Возвращается значение this

---

Функции-конструкторы также могут иметь методы. В JavaScript методы обычно добавляются к прототипу функции-конструктора, что позволяет всем экземплярам объекта делить одну и ту же функцию, вместо того чтобы создавать новую функцию для каждого объекта:
```js
function Car(make, model, year) {
  this.make = make;
  this.model = model;
  this.year = year;
}

Car.prototype.getAge = function() {
  const currentYear = new Date().getFullYear();
  return currentYear - this.year;
}

let myCar = new Car('Toyota', 'Corolla', 2005);
console.log(myCar.getAge());  // выводит возраст автомобиля
```
В этом примере все объекты, созданные с помощью `new Car(...)`, будут иметь метод `getAge`, который они наследуют от своего прототипа.

[Оглавление - JavaScript 🔼](#menu)

<div id="36"></div>

## 36. Микро и макро таски в JavaScript

**Подробнее -** [Микро и Макро задачи](https://learn.javascript.ru/event-loop)

В JavaScript существуют два вида задач (тасков): макрозадачи (macrotasks) и микрозадачи (microtasks). Эти два типа задач обрабатываются в разных очередях и имеют разные приоритеты при выполнении.

Макрозадачи включают в себя:

-   setTimeout
-   setInterval
-   setImmediate (только в Node.js)
-   Запросы I/O
-   UI рендеринг

Микрозадачи включают в себя:

-   Promise.then
-   process.nextTick (только в Node.js)
-   MutationObserver (в браузерах)

Приоритет выполнения микрозадач выше, чем макрозадач. Если в очереди микрозадач существуют задачи, они будут выполнены до того, как будет выполнена следующая макрозадача.

Это очень важно для понимания асинхронного поведения JavaScript. Когда макрозадача выполняется и в процессе ее выполнения ставятся микрозадачи (например, через `Promise.then`), эти микрозадачи будут выполнены сразу после завершения текущей макрозадачи и перед началом следующей макрозадачи. Это может привести к ситуации, когда микрозадача, поставленная в очередь позже, выполнится раньше макрозадачи, поставленной в очередь ранее.

Вот пример:
```js
console.log('script start');

setTimeout(function() {
  console.log('setTimeout');
}, 0);

Promise.resolve().then(function() {
  console.log('promise1');
}).then(function() {
  console.log('promise2');
});

console.log('script end');
```
В этом примере вывод будет следующим:
```shell
script start
script end
promise1
promise2
setTimeout
```
Это происходит потому, что `setTimeout` ставит задачу в очередь макрозадач, в то время как `Promise.resolve().then` ставит задачу в очередь микрозадач. Задачи из очереди микрозадач всегда выполняются перед задачами из очереди макрозадач.

[Оглавление - JavaScript 🔼](#menu)

<div id="37"></div>

## 37. Что такое генераторы в JavaScript и как они работают?

**Подробнее –** [Генераторы](https://learn.javascript.ru/generators)

Генераторы в JavaScript — это специальный вид функций, которые можно приостанавливать и возобновлять позже, после их первоначального вызова. Они были введены в стандарте ES6 (ECMAScript 2015) и представляют собой мощный инструмент для работы с асинхронным кодом и итерациями.

Генераторы объявляются с использованием синтаксиса `function*` (звёздочка после ключевого слова `function`), и они могут содержать одно или более выражение `yield`, которое приостанавливает выполнение генератора.

Вот простой пример генератора:
```js
function* idGenerator() {
  let id = 1;
  while (true) {
    yield id++;
  }
}

const gen = idGenerator();

console.log(gen.next().value); // 1
console.log(gen.next().value); // 2
console.log(gen.next().value); // 3
// и так далее...
```
В этом примере `idGenerator` — это генератор, который бесконечно создаёт уникальные идентификаторы. Вызов `gen.next()` возобновляет выполнение генератора и возвращает следующий идентификатор.

Важно отметить, что каждый вызов `gen.next()` возвращает объект, содержащий два свойства: `value` (значение, сгенерированное выражением `yield`) и `done` (булево значение, указывающее, завершён ли генератор). В данном случае мы игнорируем свойство `done`, так как генератор никогда не завершится из-за бесконечного цикла `while`.

Генераторы могут быть использованы для создания итерируемых объектов, асинхронного программирования с использованием `yield` вместо обратных вызовов (callbacks) или промисов, а также для управления потоком выполнения программы.

[Оглавление - JavaScript 🔼](#menu)







<div id="42"></div>

## 42. Что представляют из себя регулярные выражения и для чего они нужны?

**Подробнее –** [Регулярные выражения](https://learn.javascript.ru/regular-expressions)

Регулярные выражения (или regex) — это мощный инструмент для работы со строками. Они представляют из себя последовательность символов, формирующую шаблон поиска, и используются для сопоставления, замены или извлечения информации из текста.

Регулярные выражения позволяют:

-   Искать текст в строке.
-   Заменять подстроки в строке.
-   Извлекать конкретную информацию из строки.
-   Разделять строку на подстроки.

В JavaScript регулярные выражения обычно создаются двумя способами:
1. Через литерал регулярного выражения, заключенный в прямые слэши:
```js
const regex = /ab+c/;
```
2. Через конструктор RegExp:
```js
const regex = new RegExp('ab+c');
```

Регулярные выражения часто используют специальные символы, такие как `.` (любой символ), `*` (ноль или более повторений), `+` (одно или более повторений), `?` (ноль или одно повторение), `^` (начало строки), `$` (конец строки) и многие другие.

Вот пример использования регулярного выражения для поиска всех вхождений подстроки "ab" или "ac" в строке:
```js
const regex = /a[bc]/g;
const string = 'abc ac adc';
const matches = string.match(regex);  // Вернет: ["ab", "ac"]
```
В этом примере `[bc]` означает "любой символ из списка `b`, `c`", а `g` - это флаг "глобального" поиска, который ищет все вхождения, а не только первое.

[Оглавление - JavaScript 🔼](#menu)

<div id="43"></div>

## 43. WeakSet и WeakMap отличие от Map и Set?

**Подробнее –** [WeakMap и WeakSet](https://learn.javascript.ru/weakmap-weakset)

`WeakSet` и `WeakMap` - это специальные виды коллекций в JavaScript, которые отличаются от `Set` и `Map` основным образом: они не предотвращают сборку мусора своих элементов. Другими словами, если нет других ссылок на объект, который является ключом в `WeakMap` или элементом `WeakSet`, этот объект может быть автоматически удален сборщиком мусора.

Основные отличия `WeakSet` и `WeakMap` от `Set` и `Map`:

1.  **Сборка мусора**: Как уже было сказано, `WeakSet` и `WeakMap` не предотвращают сборку мусора своих элементов. Это полезно для структур данных, которые должны связывать объекты, не предотвращая их удаление при необходимости.
2.  **Типы ключей**: В `WeakSet` могут быть только объекты, а не примитивные значения (такие как числа или строки). Аналогично, в `WeakMap` ключами могут быть только объекты.
3.  **Перечисляемость**: `WeakSet` и `WeakMap` не перечисляемы, то есть нет способа получить список всех элементов или ключей в них. Это связано с тем, как они взаимодействуют с системой сборки мусора.
4.  **Методы API**: `WeakSet` и `WeakMap` имеют меньше методов, чем `Set` и `Map`. Например, у них нет методов `size`, `clear`, `keys`, `values`, `entries`.


В целом, `WeakSet` и `WeakMap` используются в более специализированных случаях, когда нужно связать объекты без предотвращения их сборки мусора. `Set` и `Map` являются более общими структурами данных, которые могут использоваться в большем числе сценариев.



<div id="51"></div>

## 51. Зачем нужны промисы, если можно работать с асинхронным кодом с помощью функций обратного вызова (callbacks)?

Предположим, что мы хотим асинхронно получить некоторые данные с сервера, используя обратные вызовы мы сделали бы что-то вроде этого
```js
const fs = require('fs');

fs.readFile('file1.txt', 'utf8', (err, content1) => {
  if (err) throw err;
  fs.readFile('file2.txt', 'utf8', (err, content2) => {
    if (err) throw err;
    fs.readFile('file3.txt', 'utf8', (err, content3) => {
      if (err) throw err;
      console.log(content1, content2, content3);
    });
  });
});

```

Такой подход называется callback hell (адом обратных вызовов), поскольку каждый обратный вызов вложен внутрь другого, и каждый внутренний обратный вызов зависит от его родителя.

Мы можем переписать приведенный выше фрагмент используя промисы:
```js
const fs = require('fs').promises;

fs.readFile('file1.txt', 'utf8')
  .then(content1 => {
    console.log(content1);
    return fs.readFile('file2.txt', 'utf8');
  })
  .then(content2 => {
    console.log(content2);
    return fs.readFile('file3.txt', 'utf8');
  })
  .then(content3 => {
    console.log(content3);
  })
  .catch(err => {
    throw err;
  });
```
Используя промисы, мы четко видим последовательность выполнения, такой код становится намного читабельнее.

---

1.  **Предотвращение "ада обратных вызовов" (callback hell):** Когда вам нужно выполнить несколько асинхронных операций, которые зависят друг от друга, с функциями обратного вызова вы можете столкнуться с ситуацией, когда функции обратного вызова вложены друг в друга, что делает код трудночитаемым и трудно поддерживаемым. Промисы позволяют избежать этого, предоставляя способ "цепочечного" соединения асинхронных операций.
2.  **Обработка ошибок:** С промисами вы можете использовать стандартный синтаксис try/catch для обработки ошибок, в то время как с функциями обратного вызова обработка ошибок может быть более затруднительной.
3.  **Контроль над асинхронными операциями:** Промисы предоставляют методы для контроля выполнения асинхронных операций, такие как `Promise.all` и `Promise.race`, которые позволяют выполнять несколько асинхронных операций параллельно и контролировать их выполнение.
4.  **Читаемость:** Промисы делают асинхронный код более читаемым и понятным, приводя его к структуре, которая больше похожа на традиционный синхронный код.
5.  **Интеграция с новыми API и стандартами JavaScript:** Многие новые API и функции JavaScript (например, fetch API для выполнения HTTP-запросов) используют промисы, что делает их важной и необходимой частью языка.

[Оглавление - JavaScript 🔼](#menu)

<div id="52"></div>

## 52. Что будет, если добавить скрипт перед тегом body?

**Подробнее –** [Подключение скриптов](https://learn.javascript.ru/script-async-defer)

В современных сайтах скрипты обычно «тяжелее», чем HTML: они весят больше, дольше обрабатываются.

Когда браузер загружает HTML и доходит до тега <script>...</script>, он не может продолжать строить DOM. Он должен сначала выполнить скрипт. То же самое происходит и с внешними скриптами <script src="..."></script>: браузер должен подождать, пока загрузится скрипт, выполнить его, и только затем обработать остальную страницу.

Это ведёт к двум важным проблемам:
- Скрипты не видят DOM-элементы ниже себя, поэтому к ним нельзя добавить обработчики и т.д.
- Если вверху страницы объёмный скрипт, он «блокирует» страницу. Пользователи не видят содержимое страницы, пока он не загрузится и не запустится:

[Оглавление - JavaScript 🔼](#menu)







<div id="57"></div>

## 57. Mutable vs Immutable в JS

В JavaScript, как и во многих других языках программирования, типы данных могут быть категоризированы как изменяемые (**mutable**) и неизменяемые (**immutable**).

1.  **Изменяемые типы данных (Mutable)**: Изменяемые объекты - это те, которые могут быть изменены после их создания. В JavaScript, объекты и массивы являются изменяемыми. Это означает, что вы можете изменять их свойства или элементы на месте без создания нового объекта.
```js
let arr = [1, 2, 3];
arr[0] = 7; // Мы можем изменить существующий элемент массива
console.log(arr); // Выведет: [7, 2, 3]

let obj = { name: 'Alice' };
obj.name = 'Bob'; // Мы можем изменить существующее свойство объекта
console.log(obj); // Выведет: { name: 'Bob' }
```
2.  **Неизменяемые типы данных (Immutable)**: Неизменяемые объекты - это те, которые не могут быть изменены после их создания. Все примитивы в JavaScript являются неизменяемыми, включая `string`, `number`, `boolean`, `null`, `undefined` и `BigInt`.
```js
let str = 'hello';
str[0] = 'j'; // Попытка изменить символ в строке
console.log(str); // Выведет: 'hello', потому что строка осталась неизменной
```

[Оглавление - JavaScript 🔼](#menu)


<div id="61"></div>

## 61. В чем разница между host и native объектами?

В JavaScript можно выделить три категории объектов:

1.  **Встроенные (native) объекты**: Это объекты и функции, которые доступны во всех средах выполнения JavaScript. Они определены спецификацией ECMAScript и включают в себя объекты, такие как `Array`, `Date`, `RegExp`, а также глобальные функции, такие как `parseInt`, `eval` и т.д.

2.  **Хост-объекты (host objects)**: Зависящие от среды - например, в браузере хост-объектами будут объекты, связанные с окружением браузера, такие как `Window`, `Document`, `Location`, `History`, `XMLHttpRequest` и т.д. В среде Node.js хост-объектами будут глобальные объекты, такие как `global`, `process`, `Buffer` и т.д.

3.  **Пользовательские (user objects)**: Это любые объекты, определенные кодом JavaScript, написанным разработчиком.


Важно отметить, что поведение и доступность хост-объектов могут существенно варьироваться от одной среды выполнения к другой.

[Оглавление - JavaScript 🔼](#menu)

<div id="63"></div>

## 63. Анаморфизмы

Анаморфизмы — это термин из области функционального программирования, который относится к процессу строительства структуры данных из одного или нескольких значений.

Для примера анаморфизма в JavaScript можно привести функцию, которая строит массив чисел от 1 до `n`:
```js
function buildArray(n) {
    const result = [];
    for (let i = 1; i <= n; i++) {
        result.push(i);
    }
    return result;
}

console.log(buildArray(5));  // [1, 2, 3, 4, 5]
```
В данном примере `buildArray` принимает одно число и строит структуру данных (массив) из нескольких значений. Это и есть пример анаморфизма.

В более функциональном стиле анаморфизмы часто используются для реализации ленивых вычислений, где структура данных строится по мере необходимости, а не заранее.

[Оглавление - JavaScript 🔼](#menu)

<div id="64"></div>

## 64. Катаморфизмы

Катаморфизмы — это термин из области функционального программирования, который относится к процессу "свертывания" или уменьшения структуры данных до одного значения.

В JavaScript классическим примером катаморфизма является метод `reduce()` для массивов, который проходит по всем элементам массива и собирает их в единое значение.

Вот простой пример катаморфизма, где массив чисел суммируется в одно число:
```js
const array = [1, 2, 3, 4, 5];
const sum = array.reduce((accumulator, currentValue) => accumulator + currentValue, 0);
console.log(sum); // 15
```
В этом примере `reduce` берет массив чисел (структуру данных) и "свертывает" его в одно значение — сумму чисел. Это является примером катаморфизма.

Катаморфизмы — это концепция, которая выходит за рамки конкретного языка программирования. Они являются основой многих алгоритмов и операций в функциональном программировании и теории категорий.

[Оглавление - JavaScript 🔼](#menu)

<div id="65"></div>

## 65. Ключевое слово super

Ключевое слово super() в constructor используется как функция, вызывающая родительский конструктор. Её необходимо вызвать до первого обращения к ключевому слову this в теле конструктора

```js
class Animal {

  constructor(name) {
    this.speed = 0;
    this.name = name;
  }
}

class Rabbit extends Animal {

  constructor(name, earLength) {
    super(name);
    this.earLength = earLength;
  }
}

let rabbit = new Rabbit("Белый кролик", 10);
alert(rabbit.name); // Белый кролик
alert(rabbit.earLength); // 10
```

[Оглавление - JavaScript 🔼](#menu)

<div id="66"></div>

## 66. Остаточные параметры и оператор расширения (rest)

https://learn.javascript.ru/rest-parameters-spread-operator

[Оглавление - JavaScript 🔼](#menu)

<div id="67"></div>

## 67. Различия между старым js и новым js

JavaScript продолжает развиваться, и с каждым новым выпуском стандарта ECMAScript (официальное название JavaScript) вводятся новые функции и улучшения. Вот несколько ключевых различий между "старым" (обычно рассматриваемым как ES5 и ниже) и "новым" (ES6 и выше) JavaScript:

1.  **let и const**: В новом JavaScript добавлены ключевые слова `let` и `const` для объявления переменных. `let` позволяет объявлять переменные с блочной областью видимости, а `const` используется для объявления констант.

2.  **Стрелочные функции**: Стрелочные функции обеспечивают более краткий синтаксис для определения функций и не привязывают свой контекст `this`, что делает их идеально подходящими для использования в функциях обратного вызова.

3.  **Классы**: В новом JavaScript введены классы, которые обеспечивают синтаксический сахар над прототипным наследованием и делают объектно-ориентированное программирование более доступным.

4.  **Промисы и async/await**: Эти функции представляют более простой способ работы с асинхронным кодом, сравнительно с традиционными функциями обратного вызова.

5.  **Шаблонные строки**: Шаблонные строки позволяют вставлять выражения прямо в строковые литералы и поддерживают многострочные строки.

6.  **Деструктуризация**: Деструктуризация позволяет извлекать данные из массивов или объектов с использованием синтаксиса, который зеркально отображает конструкцию массива или объекта.

7.  **Операторы расширения (spread)**: Операторы расширения позволяют распаковывать элементы массива или свойства объекта.

8.  **Модули**: ES6 вводит стандартный синтаксис для импорта и экспорта функций и данных между разными файлами JavaScript.


Это лишь некоторые из многих улучшений и расширений, внесенных в новые версии JavaScript. Однако стоит заметить, что не все браузеры и среды поддерживают все новые функции, поэтому иногда может потребоваться использование транспиляторов, таких как Babel, для обеспечения обратной совместимости.


[Оглавление - JavaScript 🔼](#menu)



<div id="70"></div>

## 70. Преимущества javascript

JavaScript имеет ряд преимуществ, которые делают его одним из наиболее популярных языков программирования, особенно для разработки веб-приложений. Вот некоторые из них:

1.  **Универсальность**: JavaScript - это основной язык веб-разработки и поддерживается всеми современными веб-браузерами. Он также используется в серверной разработке (Node.js), мобильной разработке (React Native, Ionic), а также для создания десктопных приложений (Electron).

2.  **Основа большого количества фреймворков и библиотек**: React, Angular, Vue.js - это всего лишь некоторые из множества инструментов, которые базируются на JavaScript и значительно облегчают разработку.

3.  **Asynchronous и Event Driven Programming**: JavaScript поддерживает асинхронное программирование, что особенно полезно при работе с операциями ввода-вывода, такими как запросы к API, работа с файлами и т.д. Это делает его идеальным для разработки интерактивных веб-сайтов и приложений с богатым пользовательским интерфейсом.

4.  **Поддержка сообщества**: Благодаря своей популярности, JavaScript имеет обширное и активное сообщество разработчиков, которое постоянно создает и обновляет библиотеки, фреймворки и другие инструменты. Кроме того, на различных форумах и в интернете существует огромное количество обучающих материалов и ресурсов по JavaScript.

5.  **Динамическая типизация**: JavaScript - это язык с динамической типизацией, что предоставляет больше гибкости при написании кода.

6.  **Мультипарадигменный**: JavaScript поддерживает различные стили и подходы к программированию, включая объектно-ориентированное, функциональное и императивное программирование.


Вместе с преимуществами, JavaScript также имеет свои недостатки, и выбор JavaScript (или любого другого языка) в конечном итоге должен опираться на конкретные требования и контекст проекта.


[Оглавление - JavaScript 🔼](#menu)

<div id="71"></div>

## 71. что такое ECMAScript?

ECMAScript (сокращенно ES) - это стандарт, определяющий язык программирования JavaScript. ECMAScript определяет синтаксис, типы данных, операторы, функции и другие основные компоненты языка JavaScript.

Каждая новая версия ECMAScript вносит новые возможности, синтаксические улучшения, структуры данных и другие изменения в язык JavaScript. Новые функциональности позволяют разработчикам писать более эффективный, читабельный и современный код.

Стандарт ECMAScript разрабатывается и поддерживается комитетом Ecma International, который включает разработчиков из различных компаний и организаций. Целью комитета является стандартизация и эволюция языка JavaScript для обеспечения совместимости между различными реализациями и развития языка в соответствии с требованиями современной веб-разработки.

[Оглавление - JavaScript 🔼](#menu)








<div id="76"></div>

## 76. Распространение события и фазы

Событие распространяется от объекта Window до вызвавшего его элемента (event.target).

При этом событие затрагивает всех предков целевого элемента. Распространение события имеет три фазы:

- Фаза **погружения** (**capturing phase**) – событие сначала идёт сверху вниз.
- Фаза **цели** (**target phase**) – событие достигло целевого элемента.
- Фаза **всплытия** (**bubbling stage**) – событие начинает всплывать.

[Оглавление - JavaScript 🔼](#menu)





<div id="79"></div>

## 79. Методы статического объекта

Методы статического объекта в JavaScript — это методы, вызываемые на самом объекте `Object`, а не на его экземплярах. Они предоставляют различные функциональные возможности для работы с объектами. Рассмотрим основные методы статического объекта `Object` с примерами.

### 1. `Object.assign(target, ...sources)`

Копирует все перечисляемые собственные свойства из одного или более исходных объектов в целевой объект.

```javascript
const target = { a: 1 };
const source1 = { b: 2 };
const source2 = { c: 3 };

const result = Object.assign(target, source1, source2);
console.log(result); // { a: 1, b: 2, c: 3 }
```

### 2. `Object.create(proto, [propertiesObject])`

Создает новый объект с указанным объектом прототипа и свойствами.

```javascript
const proto = { greet: function() { console.log('Hello!'); } };
const obj = Object.create(proto, {
  name: {
    value: 'John',
    writable: true,
    enumerable: true,
    configurable: true
  }
});

console.log(obj.name); // 'John'
obj.greet(); // 'Hello!'
```

### 3. `Object.defineProperty(obj, prop, descriptor)`

Добавляет указанное свойство к объекту или изменяет существующее.

```javascript
const obj = {};
Object.defineProperty(obj, 'name', {
  value: 'John',
  writable: false, // свойство нельзя изменить
  enumerable: true,
  configurable: true
});

console.log(obj.name); // 'John'
obj.name = 'Doe'; // Попытка изменить значение
console.log(obj.name); // 'John' (значение не изменилось)
```

### 4. `Object.defineProperties(obj, props)`

Добавляет несколько свойств к объекту или изменяет их.

```javascript
const obj = {};
Object.defineProperties(obj, {
  firstName: {
    value: 'John',
    writable: true,
    enumerable: true,
    configurable: true
  },
  lastName: {
    value: 'Doe',
    writable: true,
    enumerable: true,
    configurable: true
  }
});

console.log(obj.firstName); // 'John'
console.log(obj.lastName); // 'Doe'
```

### 5. `Object.entries(obj)`

Возвращает массив из пар `[key, value]` перечисляемых свойств объекта.

```javascript
const obj = { a: 1, b: 2, c: 3 };
const entries = Object.entries(obj);
console.log(entries); // [['a', 1], ['b', 2], ['c', 3]]
```

### 6. `Object.freeze(obj)`

Замораживает объект, делая его неизменяемым.

```javascript
const obj = { a: 1 };
Object.freeze(obj);

obj.a = 2; // Ошибка или игнорирование в строгом режиме
console.log(obj.a); // 1
```

### 7. `Object.fromEntries(iterable)`

Создает объект из перечисления пар `[key, value]`.

```javascript
const entries = [['a', 1], ['b', 2], ['c', 3]];
const obj = Object.fromEntries(entries);
console.log(obj); // { a: 1, b: 2, c: 3 }
```

### 8. `Object.getOwnPropertyDescriptor(obj, prop)`

Возвращает дескриптор свойства для указанного свойства объекта.

```javascript
const obj = { a: 1 };
const descriptor = Object.getOwnPropertyDescriptor(obj, 'a');
console.log(descriptor);
// { value: 1, writable: true, enumerable: true, configurable: true }
```

### 9. `Object.getOwnPropertyDescriptors(obj)`

Возвращает все дескрипторы свойств объекта.

```javascript
const obj = { a: 1, b: 2 };
const descriptors = Object.getOwnPropertyDescriptors(obj);
console.log(descriptors);
/* {
  a: { value: 1, writable: true, enumerable: true, configurable: true },
  b: { value: 2, writable: true, enumerable: true, configurable: true }
} */
```

### 10. `Object.getOwnPropertyNames(obj)`

Возвращает массив всех собственных имен свойств объекта (включая неперечисляемые).

```javascript
const obj = { a: 1, b: 2 };
Object.defineProperty(obj, 'c', { value: 3, enumerable: false });
const names = Object.getOwnPropertyNames(obj);
console.log(names); // ['a', 'b', 'c']
```

### 11. `Object.getOwnPropertySymbols(obj)`

Возвращает массив всех символов, являющихся собственными свойствами объекта.

```javascript
const sym = Symbol('key');
const obj = { [sym]: 'value' };
const symbols = Object.getOwnPropertySymbols(obj);
console.log(symbols); // [Symbol(key)]
```

### 12. `Object.getPrototypeOf(obj)`

Возвращает прототип (внутреннее [[Prototype]]) объекта.

```javascript
const proto = {};
const obj = Object.create(proto);
console.log(Object.getPrototypeOf(obj) === proto); // true
```

### 13. `Object.is(value1, value2)`

Определяет, являются ли два значения одинаковыми.

```javascript
console.log(Object.is(25, 25)); // true
console.log(Object.is(NaN, NaN)); // true
console.log(Object.is(0, -0)); // false
```

### 14. `Object.isExtensible(obj)`

Определяет, можно ли добавлять свойства в объект.

```javascript
const obj = {};
console.log(Object.isExtensible(obj)); // true
Object.preventExtensions(obj);
console.log(Object.isExtensible(obj)); // false
```

### 15. `Object.isFrozen(obj)`

Определяет, является ли объект замороженным.

```javascript
const obj = Object.freeze({});
console.log(Object.isFrozen(obj)); // true
```

### 16. `Object.isSealed(obj)`

Определяет, является ли объект запечатанным.

```javascript
const obj = Object.seal({});
console.log(Object.isSealed(obj)); // true
```

### 17. `Object.keys(obj)`

Возвращает массив из имен собственных перечисляемых свойств объекта.

```javascript
const obj = { a: 1, b: 2, c: 3 };
const keys = Object.keys(obj);
console.log(keys); // ['a', 'b', 'c']
```

### 18. `Object.preventExtensions(obj)`

Предотвращает добавление новых свойств в объект.

```javascript
const obj = { a: 1 };
Object.preventExtensions(obj);
obj.b = 2; // Ошибка или игнорирование в строгом режиме
console.log(obj.b); // undefined
```

### 19. `Object.seal(obj)`

Запечатывает объект, предотвращая добавление или удаление свойств.

```javascript
const obj = { a: 1 };
Object.seal(obj);
delete obj.a; // Ошибка или игнорирование в строгом режиме
console.log(obj.a); // 1
```

### 20. `Object.setPrototypeOf(obj, proto)`

Устанавливает прототип (внутреннее [[Prototype]]) объекта на другой объект или `null`.

```javascript
const proto = { greet: function() { console.log('Hello!'); } };
const obj = {};
Object.setPrototypeOf(obj, proto);
obj.greet(); // 'Hello!'
```

### 21. `Object.values(obj)`

Возвращает массив значений собственных перечисляемых свойств объекта.

```javascript
const obj = { a: 1, b: 2, c: 3 };
const values = Object.values(obj);
console.log(values); // [1, 2, 3]
```

[Оглавление - JavaScript 🔼](#menu)

<div id="80"></div>

## 80. Операторы логического присваивания

операторы включают логическое И (`&&=`), логическое ИЛИ (`||=`) и оператор нулевого слияния (`??=`)

### Основные операторы логического присваивания

1. **`&&=` (AND assignment)**:
   - Присваивает значение правой части выражения, если левая часть истинна.

   ```javascript
   let a = true;
   let b = 10;

   a &&= b; // a = a && b
   console.log(a); // 10

   let c = false;
   let d = 20;

   c &&= d; // c = c && d
   console.log(c); // false
   ```

2. **`||=` (OR assignment)**:
   - Присваивает значение правой части выражения, если левая часть ложна или неопределена.

   ```javascript
   let e = null;
   let f = 30;

   e ||= f; // e = e || f
   console.log(e); // 30

   let g = 40;
   let h = 50;

   g ||= h; // g = g || h
   console.log(g); // 40
   ```

3. **`??=` (Nullish assignment)**:
   - Присваивает значение правой части выражения, если левая часть равна `null` или `undefined`.

   ```javascript
   let i = null;
   let j = 60;

   i ??= j; // i = i ?? j
   console.log(i); // 60

   let k = 70;
   let l = 80;

   k ??= l; // k = k ?? l
   console.log(k); // 70
   ```

### Как работают логические операторы присваивания

- **`&&=`**: Работает аналогично оператору `&&`. Присваивание происходит только в том случае, если левый операнд является истинным (truthy). Если левый операнд является ложным (falsy), присваивание не происходит, и левый операнд сохраняет свое значение.

- **`||=`**: Работает аналогично оператору `||`. Присваивание происходит только в том случае, если левый операнд является ложным (falsy). Если левый операнд является истинным (truthy), присваивание не происходит, и левый операнд сохраняет свое значение.

- **`??=`**: Работает аналогично оператору нулевого слияния `??`. Присваивание происходит только в том случае, если левый операнд является `null` или `undefined`. В остальных случаях присваивание не происходит.

### Применение

Эти операторы упрощают запись и читаемость кода, когда необходимо выполнить логическую проверку и присвоить значение переменной только в определенных условиях. Они особенно полезны при работе с настройками по умолчанию, опциональными параметрами и проверкой значений.

[Оглавление - JavaScript 🔼](#menu)

<div id="84"></div>

## 84. Структуры данных

В JavaScript есть несколько ключевых структур данных, каждая из которых предназначена для различных задач и сценариев использования. Вот более структурированный и подробный обзор основных структур данных, включая ваши дополнения:

### 1. **Стек (Stack)**

- **Принцип**: LIFO (Last In, First Out) — последний пришедший элемент выходит первым.
- **Описание**: Стек представляет собой коллекцию элементов, где добавление и удаление элементов происходит только с одного конца (верха стека).
- **Применение**: Используется для управления вызовами функций, реализации алгоритмов обратного обхода, и многого другого.

### 2. **Очередь (Queue)**

- **Принцип**: FIFO (First In, First Out) — первый пришедший элемент выходит первым.
- **Описание**: Очередь представляет собой коллекцию элементов, где добавление элементов происходит с одного конца (заднего конца очереди), а удаление — с другого конца (переднего конца очереди).
- **Применение**: Используется в алгоритмах обработки данных, планировщиках задач, и для реализации буферов.

### 3. **Коллекции**

- **Set**:
  - **Описание**: Коллекция уникальных значений. Значения могут быть любого типа.
  - **Применение**: Используется для хранения уникальных элементов и выполнения операций над множествами (например, объединение, пересечение).

- **Map**:
  - **Описание**: Коллекция пар "ключ-значение", где ключи могут быть любого типа. Сохраняет порядок вставки ключей.
  - **Применение**: Используется для создания коллекций, где ключи могут быть любого типа и порядок вставки важен.

### 4. **Хэш-таблицы (Hash Tables)**

- **Описание**: Специализированная структура данных для хранения пар "ключ-значение" с быстрым доступом. Реализована в JavaScript с помощью объекта `Map`.
- **Принцип**: Использует хэш-функцию для вычисления индекса, по которому будет храниться значение.
- **Применение**: Используется для эффективного поиска, вставки и удаления элементов.

### 5. **Деревья**

- **Описание**: Дерево — это иерархическая структура данных, где каждый узел имеет значение и ноль или более дочерних узлов.
- **Применение**: Используется для представления иерархических данных, таких как структуры каталогов, и для реализации алгоритмов поиска.

### 6. **Графы**

- **Описание**: Граф — это структура данных, состоящая из узлов (вершин) и ребер (связей) между ними. Графы могут быть направленными или ненаправленными.
- **Применение**: Используется для моделирования сложных сетей, таких как маршруты, социальные сети и зависимости.

### 7. **Связный список (Linked List)**

- **Описание**: Связный список — структура данных, где каждый узел содержит данные и указатель на следующий узел. Это позволяет эффективно вставлять и удалять элементы.
- **Применение**: Используется для реализации списков, очередей и стэков.

[Оглавление - JavaScript 🔼](#menu)



<div id="88"></div>

## 88. Разница между `<script>` `<script async>` `<scrypt defer>`

В HTML теги `<script>`, `<script async>`, и `<script defer>` управляют тем, как загружаются и выполняются JavaScript-скрипты. Вот в чем разница:

### 1. `<script>` (по умолчанию)
- **Загрузка:** Скрипт загружается немедленно после того, как браузер встретит его в HTML. Загрузка HTML приостанавливается, пока скрипт не будет загружен.
- **Выполнение:** Скрипт выполняется немедленно после загрузки. Это происходит до того, как будет продолжена загрузка остального содержимого страницы.
- **Использование:** Обычно используется для скриптов, которые необходимы для рендеринга страницы или должны быть выполнены до того, как будет загружено другое содержимое.

```html
<script src="script.js"></script>
```

### 2. `<script async>`
- **Загрузка:** Скрипт загружается параллельно с загрузкой HTML (асинхронно).
- **Выполнение:** Скрипт выполняется сразу после загрузки, не дожидаясь полной загрузки HTML. Это может привести к выполнению скриптов в непредсказуемом порядке, если на странице несколько скриптов.
- **Использование:** Идеально подходит для независимых скриптов, таких как аналитика, реклама или трекеры, которые не зависят от других скриптов и не влияют на рендеринг страницы.

```html
<script async src="script.js"></script>
```

### 3. `<script defer>`
- **Загрузка:** Скрипт загружается параллельно с загрузкой HTML (асинхронно).
- **Выполнение:** Скрипт выполняется только после полной загрузки и разбора HTML-документа. Скрипты с атрибутом `defer` выполняются в порядке их появления на странице.
- **Использование:** Подходит для скриптов, которые зависят от DOM или должны быть выполнены после загрузки всей страницы.

```html
<script defer src="script.js"></script>
```

### Сравнение
- **`<script>`:** Блокирует загрузку HTML, выполняется немедленно после загрузки.
- **`<script async>`:** Не блокирует загрузку HTML, выполняется сразу после загрузки, но порядок выполнения может быть произвольным.
- **`<script defer>`:** Не блокирует загрузку HTML, выполняется после загрузки и разбора всего HTML, в порядке их появления на странице.

Если скрипт влияет на рендеринг или зависит от структуры DOM, лучше использовать `defer`. Если скрипт независим от других и не влияет на рендеринг, используйте `async`.

---

`<script>` Скрипты лучше подключать в конце HTML перед закрывающим тегом `</body>`. **Если** подключать javaScript в начале, то body не будет отрисовываться, пока не выполнится подключаемый js скрипт. Потому рекомендуется подключать js в конце, чтобы не блокировать рендер

Лучшим местом для подключения скриптов в HTML-документе является конец тега `<body>`, перед закрывающим тегом `</body>`. Это связано с тем, что браузер обрабатывает HTML-код сверху вниз и загружает ресурсы в том порядке, в котором они встречаются в коде.

[Оглавление - JavaScript 🔼](#menu)



<div id="90"></div>

## 90. Что такое `Compose`

`compose` — это функция высшего порядка, которая комбинирует несколько функций в одну. Она позволяет последовательно применять несколько функций к одному аргументу, передавая результат одной функции как аргумент следующей. В функциональном программировании `compose` часто используется для объединения простых функций в более сложные.

Типичная реализация `compose` принимает несколько функций и возвращает новую функцию:

```javascript
const compose = (...functions) => (arg) =>
    functions.reduceRight((acc, fn) => fn(acc), arg);
```

В этом примере функции выполняются справа налево (начиная с последней функции).

Пример использования `compose`:

```javascript
const add = x => x + 1;
const multiply = x => x * 2;

const addThenMultiply = compose(multiply, add);

console.log(addThenMultiply(5)); // 12 (сначала 5 + 1 = 6, затем 6 * 2 = 12)
```

Здесь функция `compose` сначала применяет функцию `add`, а затем передает результат в функцию `multiply`.

`compose` часто используется в функциональном программировании для построения более сложных функций из простых, улучшения читаемости кода и избегания вложенных вызовов.

[Оглавление - JavaScript 🔼](#menu)



<div id="92"></div>

## 92. Что такое `Service worker`?

Service Worker — это скрипт, который браузер запускает в фоновом режиме, отдельно от веб-страницы. Он позволяет перехватывать и обрабатывать сетевые запросы, управлять кэшем и поддерживать функциональность офлайн-приложений. Service Workers являются важной частью технологий Progressive Web Apps (PWA).

### Основные особенности и возможности Service Worker:

1. **Фоновая работа**: Service Worker работает в отдельном потоке и не влияет напрямую на пользовательский интерфейс. Он активируется только при выполнении определенных задач, таких как обработка сетевых запросов или фоновые синхронизации.

2. **Кэширование и управление сетевыми запросами**: Service Worker может перехватывать запросы к сети, кэшировать ресурсы и возвращать их из кэша без необходимости обращения к серверу. Это особенно полезно для создания офлайн-приложений.

3. **Офлайн-режим**: Service Worker позволяет создавать приложения, которые могут работать без подключения к Интернету, предоставляя кэшированные данные и отвечая на запросы из локального кэша.

4. **Фоновая синхронизация**: Service Worker поддерживает фоновую синхронизацию данных, позволяя выполнять задачи (например, отправку данных на сервер) в моменты, когда устройство подключено к сети, даже если пользователь не взаимодействует с приложением.

5. **Push-уведомления**: Service Worker может использоваться для отправки push-уведомлений пользователю, даже когда веб-приложение закрыто.

### Пример базовой работы с Service Worker:

1. **Регистрация Service Worker**: В JavaScript вы регистрируете Service Worker из основного потока вашего приложения (обычно в файле `index.js` или `main.js`):

```javascript
if ('serviceWorker' in navigator) {
    navigator.serviceWorker.register('/service-worker.js')
    .then(registration => {
        console.log('Service Worker registered with scope:', registration.scope);
    })
    .catch(error => {
        console.log('Service Worker registration failed:', error);
    });
}
```

2. **Service Worker файл (`service-worker.js`)**:

```javascript
self.addEventListener('install', event => {
    event.waitUntil(
        caches.open('my-cache-v1').then(cache => {
            return cache.addAll([
                '/',
                '/index.html',
                '/styles.css',
                '/script.js',
                '/image.png'
            ]);
        })
    );
    console.log('Service Worker installed');
});

self.addEventListener('fetch', event => {
    event.respondWith(
        caches.match(event.request).then(response => {
            return response || fetch(event.request);
        })
    );
    console.log('Service Worker fetched');
});
```

### Этапы жизненного цикла Service Worker:

1. **Установка (Install)**: Этот этап происходит при первом попадании Service Worker на страницу. В этот момент можно загрузить и кэшировать необходимые ресурсы.
2. **Активизация (Activate)**: После установки Service Worker активируется. В этот момент можно очистить старые кэши или выполнить другие задачи подготовки к работе.
3. **Прослушивание событий (Event listeners)**: После активации Service Worker может перехватывать сетевые запросы, синхронизацию, push-уведомления и другие события.

### Применение:
- Создание офлайн-приложений.
- Улучшение производительности за счет кэширования ресурсов.
- Обеспечение фона загрузки и синхронизации данных.
- Управление push-уведомлениями.

Service Worker — мощный инструмент для улучшения пользовательского опыта и производительности веб-приложений.

[Оглавление - JavaScript 🔼](#menu)

<div id="93"></div>

## 93. Что такое `Web Worker`

**Web Worker** — это технология, позволяющая выполнять JavaScript-код в фоновом потоке, отдельном от основного потока пользовательского интерфейса. Это особенно полезно для выполнения тяжелых вычислительных задач, которые могут блокировать основной поток и замедлять работу веб-приложения.

### Основные особенности Web Worker:

1. **Фоновое выполнение**: Web Worker работает в отдельном потоке, не блокируя основной поток, который отвечает за рендеринг пользовательского интерфейса. Это помогает предотвратить зависание страницы и улучшить отклик интерфейса.

2. **Асинхронность**: Код, выполняемый в Web Worker, выполняется асинхронно. Основной поток может продолжать свою работу, пока Worker выполняет задачи в фоне.

3. **Ограниченный доступ**: Web Worker не имеет доступа к DOM, `window`, `document` или `parent` объектам. Это сделано для предотвращения конфликтов и улучшения безопасности. Однако он может взаимодействовать с основной страницей через сообщения.

4. **Взаимодействие с основной страницей**: Web Worker и основной поток могут обмениваться данными с помощью метода `postMessage()` и слушателя событий `onmessage`.

5. **Типы Web Workers**:
   - **Dedicated Workers**: Эти Web Workers обслуживают только одну конкретную страницу.
   - **Shared Workers**: Эти Web Workers могут использоваться несколькими страницами или окнами одновременно.
   - **Service Workers**: Как упоминалось ранее, это особый тип Web Worker, который выполняет функции кэширования и управления сетевыми запросами.

### Пример использования Web Worker

1. **Создание файла Web Worker** (`worker.js`):

```javascript
// worker.js
self.onmessage = function(e) {
    console.log('Worker received message:', e.data);
    const result = e.data[0] * e.data[1];
    self.postMessage(result);
};
```

2. **Использование Web Worker в основном скрипте**:

```javascript
// main.js
if (window.Worker) {
    const myWorker = new Worker('worker.js');

    myWorker.postMessage([10, 20]); // Отправляем сообщение в Worker

    myWorker.onmessage = function(e) {
        console.log('Result from worker:', e.data); // 200
    };

    myWorker.onerror = function(error) {
        console.log('Worker error:', error);
    };
}
```

### Пример объяснения:

- В основном скрипте создается новый экземпляр Web Worker с помощью конструктора `Worker`, который загружает файл `worker.js`.
- Основной поток отправляет данные в Worker с помощью метода `postMessage`.
- Web Worker выполняет вычисления и возвращает результат обратно в основной поток с помощью метода `postMessage`.
- Основной поток получает результат через обработчик события `onmessage`.

### Применение Web Workers:

1. **Выполнение сложных вычислений**: Web Workers отлично подходят для выполнения интенсивных задач, таких как обработка больших массивов данных, выполнение математических расчетов или рендеринг графики.

2. **Фоновые задачи**: Web Workers могут использоваться для выполнения фоновых задач, таких как обработка данных, загрузка файлов или анализ данных, которые не требуют взаимодействия с DOM.

3. **Поддержка многопоточности**: Web Workers позволяют создавать многопоточные веб-приложения, что особенно полезно в веб-приложениях с интенсивным использованием ресурсов.

Web Workers помогают улучшить производительность веб-приложений, делая их более отзывчивыми и обеспечивая лучший пользовательский опыт.

[Оглавление - JavaScript 🔼](#menu)

<div id="94"></div>

## 94. что такое ES Модуль

**ES-модуль (ECMAScript модуль)** — это стандартный способ организации и управления кодом в JavaScript, который был введен в спецификации ECMAScript 6 (ES6). Он позволяет разработчикам разбивать код на отдельные, повторно используемые и изолированные модули, которые могут импортироваться и экспортироваться между файлами.

### Основные особенности ES-модулей:

1. **Экспорт и импорт**: ES-модули позволяют экспортировать функции, объекты, переменные и классы из одного модуля и импортировать их в другой. Это упрощает управление зависимостями и улучшает структурирование кода.

2. **Изоляция кода**: Код, определенный в модуле, по умолчанию изолирован от глобальной области видимости. Это предотвращает конфликты переменных и улучшает безопасность кода.

3. **Статический анализ**: Импорты и экспорты ES-модулей могут быть проверены на этапе компиляции, что позволяет более эффективно выявлять ошибки и оптимизировать код.

4. **Поддержка браузерами**: Современные браузеры поддерживают ES-модули напрямую через `<script type="module">`. Также ES-модули поддерживаются в Node.js.

### Экспорт и импорт в ES-модулях:

#### Экспорт:
Вы можете экспортировать части кода из модуля, чтобы они были доступны для импорта в других модулях.

1. **Именованный экспорт**: Позволяет экспортировать несколько сущностей из одного модуля.

```javascript
// utils.js
export function add(a, b) {
    return a + b;
}

export const PI = 3.14;
```

2. **Экспорт по умолчанию (default export)**: Позволяет экспортировать одну сущность по умолчанию из модуля. Модуль может иметь только один экспорт по умолчанию.

```javascript
// math.js
export default function subtract(a, b) {
    return a - b;
}
```

#### Импорт:
Вы можете импортировать экспортированные сущности из другого модуля в свой код.

1. **Импорт именованных сущностей**:

```javascript
// main.js
import { add, PI } from './utils.js';

console.log(add(2, 3)); // 5
console.log(PI); // 3.14
```

2. **Импорт по умолчанию**:

```javascript
// main.js
import subtract from './math.js';

console.log(subtract(5, 2)); // 3
```

3. **Импорт всего модуля как объекта**:

```javascript
// main.js
import * as Utils from './utils.js';

console.log(Utils.add(2, 3)); // 5
console.log(Utils.PI); // 3.14
```

### Поддержка ES-модулей в браузерах:
В браузерах ES-модули можно загружать с помощью тега `<script>` с атрибутом `type="module"`:

```html
<script type="module">
    import { add } from './utils.js';
    console.log(add(2, 3)); // 5
</script>
```

### ES-модули в Node.js:
Node.js с версии 12 и выше поддерживает ES-модули. Вы можете использовать расширение `.mjs` для файлов модулей или указать `"type": "module"` в файле `package.json`.

```json
{
  "type": "module"
}
```

После этого вы сможете использовать синтаксис `import` и `export` в JavaScript-файлах с расширением `.js`.

### Преимущества ES-модулей:
- **Модульность**: Позволяет разбивать приложение на более мелкие, управляемые и повторно используемые модули.
- **Повышение безопасности**: За счет изоляции кода и избежания конфликтов переменных.
- **Совместимость**: ES-модули становятся стандартом, поддерживаемым в браузерах и серверах.

ES-модули значительно улучшили способ организации кода в JavaScript, сделав его более структурированным, понятным и легким в обслуживании.

[Оглавление - JavaScript 🔼](#menu)

<div id="95"></div>

## 95. JS особенности

JavaScript обладает следующими ключевыми особенностями:

- **Динамическая типизация**: Язык не требует явного указания типов данных, которые могут изменяться во время выполнения. Это упрощает написание кода, но может привести к неожиданным ошибкам.

- **Интеграция с HTML и CSS**: JavaScript тесно интегрирован с HTML и CSS, что позволяет динамически изменять содержимое веб-страниц и стили на основе взаимодействия пользователя или других условий.

- **Обработка событий и взаимодействие с DOM**: JavaScript обеспечивает обработку событий (например, кликов, ввода данных) и позволяет взаимодействовать с элементами DOM, что позволяет создавать интерактивные и динамичные веб-приложения.

- **Однопоточность и асинхронность**: Хотя JavaScript является однопоточным и выполняет задачи поочередно в единственном потоке выполнения (основной поток), он поддерживает асинхронное программирование с использованием `callback` функций, `Promises`, и `async/await`, что позволяет обрабатывать длительные операции (например, сетевые запросы) без блокировки основного потока.

Эти особенности делают JavaScript мощным инструментом для веб-разработки, позволяя создавать сложные и интерактивные веб-приложения.

[Оглавление - JavaScript 🔼](#menu)

<div id="96"></div>

## 96.

**Сборщик мусора (Garbage Collector, GC)** — это механизм управления памятью, который автоматически освобождает память, занимаемую объектами, которые больше не используются программой. Он помогает предотвратить утечки памяти и оптимизировать использование ресурсов, избавляя разработчиков от необходимости вручную управлять памятью.

### Основные функции сборщика мусора:

1. **Автоматическое управление памятью**: Сборщик мусора автоматически определяет и освобождает память, занятую объектами, которые больше не доступны в программе.

2. **Уменьшение утечек памяти**: Путем регулярного освобождения неиспользуемой памяти сборщик мусора помогает предотвратить утечки памяти, которые могут возникать, если память не освобождается должным образом.

3. **Оптимизация использования ресурсов**: Сборщик мусора помогает оптимизировать использование памяти и ресурсы, освобождая неактивные объекты и ресурсы.

### Как это работает:

1. **Отслеживание ссылок**: Сборщик мусора отслеживает объекты в памяти и их ссылки. Если объект больше не доступен (то есть на него не ссылается ни один активный участок кода), он становится кандидатом на удаление.

2. **Методы сбора мусора**:
   - **Сборка мусора по меткам (Mark-and-Sweep)**: Сборщик мусора проходит по всем объектам и отмечает те, на которые есть ссылки. Затем он очищает объекты, на которые не осталось ссылок.
   - **Сборка мусора по поколению (Generational Garbage Collection)**: Объекты разделяются на поколения в зависимости от их возраста. Молодые объекты собираются чаще, поскольку они часто оказываются ненужными, тогда как старые объекты могут быть собраны реже.
   - **Сборка мусора по отслеживанию (Reference Counting)**: Каждый объект имеет счетчик ссылок, который отслеживает количество ссылок на объект. Когда счетчик становится равным нулю, объект удаляется.

3. **Частота выполнения**: Сборка мусора выполняется автоматически в фоновом режиме и может быть запущена в разные моменты времени, в зависимости от реализации и состояния памяти.

### Пример в JavaScript:

JavaScript использует сборщик мусора для автоматического управления памятью. Например, если вы создаете объекты, которые больше не используются, сборщик мусора освободит их память.

```javascript
function createObject() {
    let largeObject = { data: new Array(1000000).fill('data') };
    // largeObject доступен только в этой функции
}
// Когда createObject завершится, largeObject больше не будет доступен
// Сборщик мусора освободит память, занятую largeObject
createObject();
```

[Оглавление - JavaScript 🔼](#menu)






<div id="102"></div>

## 102. `Intl` - интернационализация в JavaScript

ссылка - https://learn.javascript.ru/intl

`Intl` — это встроенный объект в JavaScript, который предоставляет ряд методов для интернационализации. Он помогает разработчикам форматировать числа, валюты, даты, время и строки в соответствии с локалями (регионами) пользователя. `Intl` включает несколько конструкторов, которые позволяют выполнять эти задачи:

### 1. **`Intl.NumberFormat`**
   Этот конструктор используется для форматирования чисел, например, для отображения чисел в формате валюты или с учетом десятичных знаков.

   Пример:
   ```javascript
   const number = 1234567.89;
   const formattedNumber = new Intl.NumberFormat('en-US', {
       style: 'currency',
       currency: 'USD'
   }).format(number);

   console.log(formattedNumber); // "$1,234,567.89"
   ```

### 2. **`Intl.DateTimeFormat`**
   Этот конструктор используется для форматирования даты и времени в соответствии с определенной локалью.

   Пример:
   ```javascript
   const date = new Date();
   const formattedDate = new Intl.DateTimeFormat('ru-RU', {
       year: 'numeric',
       month: 'long',
       day: 'numeric'
   }).format(date);

   console.log(formattedDate); // "14 августа 2024 г."
   ```

### 3. **`Intl.Collator`**
   `Intl.Collator` используется для сравнения строк с учетом особенностей конкретной локали, что может быть полезно для сортировки.

   Пример:
   ```javascript
   const collator = new Intl.Collator('ru-RU');
   const result = collator.compare('а', 'я');

   console.log(result); // -1 (означает, что 'а' предшествует 'я' в русском алфавите)
   ```

### 4. **`Intl.RelativeTimeFormat`**
   Этот конструктор используется для форматирования относительных временных отрезков, например, "2 дня назад" или "через 3 недели".

   Пример:
   ```javascript
   const rtf = new Intl.RelativeTimeFormat('ru', { numeric: 'auto' });
   console.log(rtf.format(-1, 'day')); // "вчера"
   console.log(rtf.format(2, 'week')); // "через 2 недели"
   ```

### 5. **`Intl.ListFormat`**
   `Intl.ListFormat` используется для форматирования списков элементов в соответствии с локалью.

   Пример:
   ```javascript
   const items = ['яблоки', 'апельсины', 'бананы'];
   const formattedList = new Intl.ListFormat('ru-RU', { style: 'long', type: 'conjunction' }).format(items);

   console.log(formattedList); // "яблоки, апельсины и бананы"
   ```

### 6. **`Intl.PluralRules`**
   Этот конструктор позволяет определять правила множественного числа для различных локалей, что полезно при построении строк с числовыми значениями.

   Пример:
   ```javascript
   const pr = new Intl.PluralRules('ru-RU');
   console.log(pr.select(1)); // "one"
   console.log(pr.select(2)); // "few"
   console.log(pr.select(5)); // "many"
   ```

Использование объекта `Intl` позволяет делать ваши приложения более доступными для пользователей из разных регионов, адаптируя отображение данных под их языковые и культурные предпочтения.

[Оглавление - JavaScript 🔼](#menu)

<div id="103"></div>

## 103. Структуры данных и Сложность алгоритмов

[ссылка на подробное](https://proglib.io/p/rasprostranennye-algoritmy-i-struktury-dannyh-v-javascript-osnovnye-ponyatiya-i-rabota-s-massivami-2021-10-06)

## Структуры данных

1. Массив
2. Объект (класс сахар над прототипным наследованием)
3. Коллекции (Set, Map)
4. Хэш таблица (объект, Map) - используют хэш-функции для хранения данных в виде пар "ключ-значение".
5. Связные списки - состоят из узлов, каждый из которых содержит данные и ссылку на следующий узел.
6. Бинарные деревья - состоят из узлов с родительскими и дочерними ветвями
7. Графы - представляют собой набор узлов, соединенных ребрами.
8. Очередь - это структуры данных, работающие по принципу FIFO (First In, First Out).
9. Стек - это структуры данных, работающие по принципу LIFO (Last In, First Out).

## Анализ сложности алгоритмов:

**O большое (Big O)** — это нотация, используемая для описания асимптотической временной и пространственной сложности алгоритмов. Она показывает, как время выполнения или использование памяти алгоритма растет в зависимости от размера входных данных. Основная цель Big O — оценить наихудший сценарий поведения алгоритма.

1. **Временная сложность:**

    **1) O(1) — Константная сложность:**

    - Время выполнения не зависит от размера входных данных.
    - Пример: Доступ к элементу массива по индексу.

    **2) O(n) — Линейная сложность:**

    - Время выполнения растет линейно с увеличением размера входных данных.
    - Пример: Линейный поиск в массиве.

    **3) O(log n) — Логарифмическая сложность:**

    - Время выполнения растет логарифмически с увеличением размера входных данных.
    - Пример: Бинарный поиск.

    **4) O(n log n) — Линейно-логарифмическая сложность:**

    - Время выполнения растет линейно-логарифмически с увеличением размера входных данных.
    - Пример: Быстрая сортировка, сортировка слиянием.

    **5) O(n^2) — Квадратичная сложность:**

    - Время выполнения растет квадратично с увеличением размера входных данных.
    - Пример: Пузырьковая сортировка.

**Алгоритмы сортировки и поиска**

- Пузырьковая сортировка - O(n²) в худшем, O(n) в лучшем случае (если массив уже отсортирован).
- Сортировка вставками - O(n²) в худшем, O(n) в лучшем случае.
- Быстрая сортировка -  O(n²) в худшем случае, O(n log n)
- Сортировка слиянием - O(n log n) во всех случаях.

**Алгоритмы сортировки и поиска**

- Линейный поиск -  O(n)
- Бинарный поиск - O(log n) (требует отсортированного массива)

2. **Пространственная сложность:**

    **1) O(1) — Константная пространственная сложность:**

    - Память не зависит от размера входных данных.
    - Пример: Сортировка вставками.

    **2) O(n) — Линейная пространственная сложность:**

    - Память растет линейно с увеличением размера входных данных.
    - Пример: Использование дополнительного массива для слияния.

[Оглавление - JavaScript 🔼](#menu)

<div id="104"></div>

## 104. Как ты будешь дебажить приложение, из-за чего бывают утечки память

Debug:

- Посмотреть нет ли ошибок в консоли, чекнуть profiler.
- Утечки памяти могут быть из-за большого количества eventListers и setTimeout, так как они остаются в памяти, если мы не сделали clearTimeout и removeEventListener.
- проверить корректность выполнения запросов во вкладке network в браузере

[Оглавление - JavaScript 🔼](#menu)
